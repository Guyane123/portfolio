{"ast":null,"code":"var _possibleConstructorReturn = require(\"C:\\\\Users\\\\Damien\\\\Desktop\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\Damien\\\\Desktop\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\Damien\\\\Desktop\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\Damien\\\\Desktop\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\nvar _wrapNativeSuper = require(\"C:\\\\Users\\\\Damien\\\\Desktop\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\nvar _taggedTemplateLiteral = require(\"C:\\\\Users\\\\Damien\\\\Desktop\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/taggedTemplateLiteral\");\nvar _toArray = require(\"C:\\\\Users\\\\Damien\\\\Desktop\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toArray\");\nvar _toConsumableArray = require(\"C:\\\\Users\\\\Damien\\\\Desktop\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\nvar _slicedToArray = require(\"C:\\\\Users\\\\Damien\\\\Desktop\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nvar _classCallCheck = require(\"C:\\\\Users\\\\Damien\\\\Desktop\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\Damien\\\\Desktop\\\\portfolio\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18;\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/*! css-doodle@0.34.5 */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.CSSDoodle = factory());\n})(this, function () {\n  'use strict';\n\n  /**\n   * This is totally rewrite for the old parser module\n   * I'll improve and replace them little by little.\n   */\n  var symbols$1 = [':', ';', ',', '(', ')', '[', ']', '{', '}', 'π', '±', '+', '-', '*', '/', '%', '\"', \"'\", '`', '@', '=', '^'];\n  var is$1 = {\n    escape: function escape(c) {\n      return c == '\\\\';\n    },\n    space: function space(c) {\n      return /[\\r\\n\\t\\s]/.test(c);\n    },\n    digit: function digit(c) {\n      return /^[0-9]$/.test(c);\n    },\n    sign: function sign(c) {\n      return /^[+-]$/.test(c);\n    },\n    dot: function dot(c) {\n      return c == '.';\n    },\n    quote: function quote(c) {\n      return /^[\"'`]$/.test(c);\n    },\n    symbol: function symbol(c) {\n      return symbols$1.includes(c);\n    },\n    hexNum: function hexNum(c) {\n      return /^[0-9a-f]$/i.test(c);\n    },\n    hex: function hex(a, b, c) {\n      return a == '0' && is$1.letter(b, 'x') && is$1.hexNum(c);\n    },\n    expWithSign: function expWithSign(a, b, c) {\n      return is$1.letter(a, 'e') && is$1.sign(b) && is$1.digit(c);\n    },\n    exp: function exp(a, b) {\n      return is$1.letter(a, 'e') && is$1.digit(b);\n    },\n    dots: function dots(a, b) {\n      return is$1.dot(a) && is$1.dot(b);\n    },\n    letter: function letter(a, b) {\n      return String(a).toLowerCase() == String(b).toLowerCase();\n    },\n    comment: function comment(a, b) {\n      return a == '/' && b == '*';\n    },\n    inlineComment: function inlineComment(a, b) {\n      return a == '/' && b === '/';\n    },\n    selfClosedTag: function selfClosedTag(a, b) {\n      return a == '/' && b == '>';\n    },\n    closedTag: function closedTag(a, b) {\n      return a == '<' && b == '/';\n    }\n  };\n  var Token = /*#__PURE__*/function () {\n    function Token(_ref) {\n      var type = _ref.type,\n        value = _ref.value,\n        pos = _ref.pos,\n        status = _ref.status;\n      _classCallCheck(this, Token);\n      this.type = type;\n      this.value = value;\n      this.pos = pos;\n      if (status) {\n        this.status = status;\n      }\n    }\n    _createClass(Token, [{\n      key: \"isSymbol\",\n      value: function isSymbol() {\n        var _this = this;\n        var isSymbol = this.type == 'Symbol';\n        for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n          values[_key] = arguments[_key];\n        }\n        if (!values.length) return isSymbol;\n        return values.some(function (c) {\n          return c === _this.value;\n        });\n      }\n    }, {\n      key: \"isSpace\",\n      value: function isSpace() {\n        return this.type == 'Space';\n      }\n    }, {\n      key: \"isNumber\",\n      value: function isNumber() {\n        return this.type == 'Number';\n      }\n    }, {\n      key: \"isWord\",\n      value: function isWord() {\n        return this.type == 'Word';\n      }\n    }]);\n    return Token;\n  }();\n  function iterator$1(input) {\n    var pointer = -1;\n    var max = input.length;\n    var col = -1,\n      row = 0;\n    return {\n      curr: function curr() {\n        var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        return input[pointer + n];\n      },\n      next: function next() {\n        var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        var next = input[pointer += n];\n        if (next === '\\n') row++, col = 0;else col += n;\n        return next;\n      },\n      end: function end() {\n        return pointer >= max;\n      },\n      get: function get() {\n        return {\n          prev: input[pointer - 1],\n          curr: input[pointer + 0],\n          next: input[pointer + 1],\n          next2: input[pointer + 2],\n          next3: input[pointer + 3],\n          pos: [col, row]\n        };\n      }\n    };\n  }\n  function skipComments(iter) {\n    while (iter.next()) {\n      var _iter$get = iter.get(),\n        curr = _iter$get.curr,\n        prev = _iter$get.prev;\n      if (is$1.comment(curr, prev)) break;\n    }\n  }\n  function skipInlineComments(iter) {\n    while (iter.next()) {\n      if (iter.curr() === '\\n') break;\n    }\n  }\n  function ignoreSpacingSymbol(value) {\n    return [':', ';', ',', '{', '}', '(', ')', '[', ']'].includes(value);\n  }\n  function readWord(iter) {\n    var temp = '';\n    while (!iter.end()) {\n      var _iter$get2 = iter.get(),\n        curr = _iter$get2.curr,\n        next = _iter$get2.next;\n      temp += curr;\n      var isBreak = is$1.symbol(next) || is$1.space(next) || is$1.digit(next);\n      if (temp.length && isBreak) {\n        if (!is$1.closedTag(curr, next)) break;\n      }\n      iter.next();\n    }\n    return temp.trim();\n  }\n  function readSpaces(iter) {\n    var temp = '';\n    while (!iter.end()) {\n      var _iter$get3 = iter.get(),\n        curr = _iter$get3.curr,\n        next = _iter$get3.next;\n      temp += curr;\n      if (!is$1.space(next)) break;\n      iter.next();\n    }\n    return temp;\n  }\n  function readNumber(iter) {\n    var temp = '';\n    var hasDot = false;\n    while (!iter.end()) {\n      var _iter$get4 = iter.get(),\n        curr = _iter$get4.curr,\n        next = _iter$get4.next,\n        next2 = _iter$get4.next2,\n        next3 = _iter$get4.next3;\n      temp += curr;\n      if (hasDot && is$1.dot(next)) break;\n      if (is$1.dot(curr)) hasDot = true;\n      if (is$1.dots(next, next2)) break;\n      if (is$1.expWithSign(next, next2, next3)) {\n        temp += iter.next() + iter.next();\n      } else if (is$1.exp(next, next2)) {\n        temp += iter.next();\n      } else if (!is$1.digit(next) && !is$1.dot(next)) {\n        break;\n      }\n      iter.next();\n    }\n    return temp;\n  }\n  function readHexNumber(iter) {\n    var temp = '0x';\n    iter.next(2);\n    while (!iter.end()) {\n      var _iter$get5 = iter.get(),\n        curr = _iter$get5.curr,\n        next = _iter$get5.next;\n      temp += curr;\n      if (!is$1.hexNum(next)) break;\n      iter.next();\n    }\n    return temp;\n  }\n  function last$1(array) {\n    return array[array.length - 1];\n  }\n  function scan(source) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var iter = iterator$1(String(source).trim());\n    var tokens = [];\n    var quoteStack = [];\n    while (iter.next()) {\n      var _iter$get6 = iter.get(),\n        prev = _iter$get6.prev,\n        curr = _iter$get6.curr,\n        next = _iter$get6.next,\n        next2 = _iter$get6.next2,\n        pos = _iter$get6.pos;\n      if (is$1.comment(curr, next)) {\n        skipComments(iter);\n      } else if (options.ignoreInlineComment && is$1.inlineComment(curr, next)) {\n        skipInlineComments(iter);\n      } else if (is$1.hex(curr, next, next2)) {\n        var num = readHexNumber(iter);\n        tokens.push(new Token({\n          type: 'Number',\n          value: num,\n          pos: pos\n        }));\n      } else if (is$1.digit(curr) || is$1.digit(next) && is$1.dot(curr) && !is$1.dots(prev, curr)) {\n        var _num = readNumber(iter);\n        tokens.push(new Token({\n          type: 'Number',\n          value: _num,\n          pos: pos\n        }));\n      } else if (is$1.symbol(curr) && !is$1.selfClosedTag(curr, next)) {\n        var _lastToken = last$1(tokens);\n        // negative\n        var isNextDigit = is$1.digit(next) || is$1.dot(next) && is$1.digit(next2);\n        if (curr === '-' && isNextDigit && (!_lastToken || !_lastToken.isNumber())) {\n          var _num2 = readNumber(iter);\n          tokens.push(new Token({\n            type: 'Number',\n            value: _num2,\n            pos: pos\n          }));\n          continue;\n        }\n        var token = {\n          type: 'Symbol',\n          value: curr,\n          pos: pos\n        };\n        // Escaped symbols\n        if (quoteStack.length && is$1.escape(_lastToken.value)) {\n          tokens.pop();\n          var word = readWord(iter);\n          if (word.length) {\n            tokens.push(new Token({\n              type: 'Word',\n              value: word,\n              pos: pos\n            }));\n          }\n        } else {\n          if (is$1.quote(curr)) {\n            var lastQuote = last$1(quoteStack);\n            if (lastQuote == curr) {\n              quoteStack.pop();\n              token.status = 'close';\n            } else {\n              quoteStack.push(curr);\n              token.status = 'open';\n            }\n          }\n          tokens.push(new Token(token));\n        }\n      } else if (is$1.space(curr)) {\n        var spaces = readSpaces(iter);\n        var _lastToken2 = last$1(tokens);\n        var _iter$get7 = iter.get(),\n          _next = _iter$get7.next; // Reduce unnecessary spaces\n        if (!quoteStack.length && _lastToken2) {\n          var _prev = _lastToken2.value;\n          var ignoreLeft = ignoreSpacingSymbol(_prev) && _prev !== ')';\n          var ignoreRight = ignoreSpacingSymbol(_next) && _next !== '(';\n          if (ignoreLeft || ignoreRight) {\n            continue;\n          } else {\n            spaces = options.preserveLineBreak ? curr : ' ';\n          }\n        }\n        if (tokens.length && _next && _next.trim()) {\n          tokens.push(new Token({\n            type: 'Space',\n            value: spaces,\n            pos: pos\n          }));\n        }\n      } else {\n        var _word = readWord(iter);\n        if (_word.length) {\n          tokens.push(new Token({\n            type: 'Word',\n            value: _word,\n            pos: pos\n          }));\n        }\n      }\n    }\n\n    // Remove last space token\n    var lastToken = last$1(tokens);\n    if (lastToken && lastToken.isSpace()) {\n      tokens.length = tokens.length - 1;\n    }\n    return tokens;\n  }\n  function parse$9(input) {\n    var iter = iterator$1(scan(input));\n    return walk$2(iter);\n  }\n  function walk$2(iter) {\n    var rules = [];\n    while (iter.next()) {\n      var _iter$get8 = iter.get(),\n        curr = _iter$get8.curr,\n        next = _iter$get8.next;\n      if (curr.value === 'var') {\n        if (next && next.isSymbol('(')) {\n          iter.next();\n          var rule = parseVar(iter);\n          if (isValid(rule.name)) {\n            rules.push(rule);\n          }\n        }\n      } else if (rules.length && !curr.isSymbol(',')) {\n        break;\n      }\n    }\n    return rules;\n  }\n  function parseVar(iter) {\n    var ret = {};\n    var tokens = [];\n    while (iter.next()) {\n      var _iter$get9 = iter.get(),\n        curr = _iter$get9.curr,\n        next = _iter$get9.next;\n      if (curr.isSymbol(')', ';') && !ret.name) {\n        ret.name = joinTokens$2(tokens);\n        break;\n      } else if (curr.isSymbol(',')) {\n        if (ret.name === undefined) {\n          ret.name = joinTokens$2(tokens);\n          tokens = [];\n        }\n        if (ret.name) {\n          ret.fallback = walk$2(iter);\n        }\n      } else {\n        tokens.push(curr);\n      }\n    }\n    return ret;\n  }\n  function joinTokens$2(tokens) {\n    return tokens.map(function (n) {\n      return n.value;\n    }).join('');\n  }\n  function isValid(name) {\n    if (name === undefined) return false;\n    if (name.length <= 2) return false;\n    if (name.substr(2).startsWith('-')) return false;\n    if (!name.startsWith('--')) return false;\n    return true;\n  }\n  function clamp(num, min, max) {\n    num = Number(num) || 0;\n    return Math.max(min, Math.min(max, num));\n  }\n  function maybe(cond, value) {\n    if (!cond) return '';\n    return typeof value === 'function' ? value() : value;\n  }\n  function range(start, stop, step) {\n    var count = 0,\n      old = start;\n    var initial = function initial(n) {\n      return n > 0 && n < 1 ? .1 : 1;\n    };\n    var length = arguments.length;\n    if (length == 1) {\n      var _ref2 = [initial(start), start];\n      start = _ref2[0];\n      stop = _ref2[1];\n    }\n    if (length < 3) step = initial(start);\n    var range = [];\n    while (step >= 0 && start <= stop || step < 0 && start > stop) {\n      range.push(start);\n      start += step;\n      if (count++ >= 65535) break;\n    }\n    if (!range.length) range.push(old);\n    return range;\n  }\n  function add_alias(obj, names) {\n    for (var _i = 0, _Object$entries = Object.entries(names); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        alias = _Object$entries$_i[0],\n        name = _Object$entries$_i[1];\n      obj[alias] = obj[name];\n    }\n    return obj;\n  }\n  function is_letter(c) {\n    return /^[a-zA-Z]$/.test(c);\n  }\n  function is_nil(s) {\n    return s === undefined || s === null;\n  }\n  function is_invalid_number(v) {\n    return is_nil(v) || Number.isNaN(v);\n  }\n  function is_empty(value) {\n    return is_nil(value) || value === '';\n  }\n  function lazy(fn) {\n    var wrap = function wrap(upstream) {\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return fn.apply(void 0, [upstream].concat(args));\n      };\n    };\n    wrap.lazy = true;\n    return wrap;\n  }\n  function sequence(count, fn) {\n    var _String$split = String(count).split(/[x-]/),\n      _String$split2 = _slicedToArray(_String$split, 2),\n      x = _String$split2[0],\n      _String$split2$ = _String$split2[1],\n      y = _String$split2$ === void 0 ? 1 : _String$split2$;\n    var _ref3 = [Math.ceil(x), Math.ceil(y)],\n      cx = _ref3[0],\n      cy = _ref3[1];\n    if (is_invalid_number(cx)) cx = 1;\n    if (is_invalid_number(cy)) cy = 1;\n    x = clamp(cx, 0, 65536);\n    y = clamp(cy, 0, 65536);\n    var max = x * y;\n    var ret = [];\n    var index = 1;\n    if (/x/.test(count)) {\n      for (var i = 1; i <= y; ++i) {\n        for (var j = 1; j <= x; ++j) {\n          ret.push(fn(index++, j, i, max, x, y, index));\n        }\n      }\n    } else if (/-/.test(count)) {\n      max = Math.abs(x - y) + 1;\n      if (x <= y) {\n        for (var _i2 = x; _i2 <= y; ++_i2) {\n          ret.push(fn(_i2, _i2, 1, max, max, 1, index++));\n        }\n      } else {\n        for (var _i3 = x; _i3 >= y; --_i3) {\n          ret.push(fn(_i3, _i3, 1, max, max, 1, index++));\n        }\n      }\n    } else {\n      for (var _i4 = 1; _i4 <= x; ++_i4) {\n        ret.push(fn(_i4, _i4, 1, x, x, 1, index++));\n      }\n    }\n    return ret;\n  }\n  function cell_id(x, y, z) {\n    return 'c-' + x + '-' + y + '-' + z;\n  }\n  function get_value(input) {\n    var v = input;\n    while (v && !is_nil(v.value)) v = v.value;\n    return is_nil(v) ? '' : v;\n  }\n  function normalize_png_name(name) {\n    var prefix = is_nil(name) ? Date.now() : String(name).replace(/\\/.png$/g, '');\n    return prefix + '.png';\n  }\n  function cache_image(src, fn) {\n    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.src = src;\n    img.onload = function () {\n      setTimeout(fn, delay);\n    };\n  }\n  function is_safari() {\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  }\n  function un_entity(code) {\n    var textarea = document.createElement('textarea');\n    textarea.innerHTML = code;\n    return textarea.value;\n  }\n  function entity(code) {\n    return code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;');\n  }\n\n  /* cyrb53 */\n  function hash(str) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var h1 = 0xdeadbeef ^ seed,\n      h2 = 0x41c6ce57 ^ seed;\n    for (var i = 0, ch; i < str.length; i++) {\n      ch = str.charCodeAt(i);\n      h1 = Math.imul(h1 ^ ch, 2654435761);\n      h2 = Math.imul(h2 ^ ch, 1597334677);\n    }\n    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);\n    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);\n    return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n  }\n  function make_tag_function(fn) {\n    var get_value = function get_value(v) {\n      return is_nil(v) ? '' : v;\n    };\n    return function (input) {\n      for (var _len3 = arguments.length, vars = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        vars[_key3 - 1] = arguments[_key3];\n      }\n      var string = make_array$1(input).reduce(function (s, c, i) {\n        return s + c + get_value(vars[i]);\n      }, '');\n      return fn(string);\n    };\n  }\n  function next_id() {\n    var id = 0;\n    return function () {\n      var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return \"\".concat(prefix, \"-\").concat(++id);\n    };\n  }\n  function lerp(t, a, b) {\n    return a + t * (b - a);\n  }\n  function unique_id() {\n    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return prefix + Math.random().toString(32).substr(2);\n  }\n  function make_array$1(arr) {\n    if (is_nil(arr)) return [];\n    return Array.isArray(arr) ? arr : [arr];\n  }\n  function get_grid(input) {\n    var _String$replace$repla = String(input + '').replace(/\\s+/g, '').replace(/[,，xX]+/g, 'x').split('x').map(function (n) {\n        return parseInt(n);\n      }),\n      _String$replace$repla2 = _slicedToArray(_String$replace$repla, 2),\n      x = _String$replace$repla2[0],\n      _String$replace$repla3 = _String$replace$repla2[1],\n      y = _String$replace$repla3 === void 0 ? x : _String$replace$repla3;\n    if (!x || x < 1) x = 1;\n    if (!y || y < 1) y = 1;\n    return {\n      x: x,\n      y: y\n    };\n  }\n  function parse$8(input) {\n    var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      symbol: ',',\n      noSpace: false,\n      verbose: false\n    };\n    var group = [];\n    var tokens = [];\n    var parenStack = [];\n    var quoteStack = [];\n    var lastGroupName = '';\n    if (is_empty(input)) {\n      return group;\n    }\n    var iter = iterator$1(scan(input));\n    function isSeperator(token) {\n      var symbol = option.symbol || [','];\n      if (!Array.isArray(symbol)) {\n        symbol = [symbol];\n      }\n      if (option.noSpace) {\n        return token.isSymbol.apply(token, _toConsumableArray(symbol));\n      }\n      return token.isSymbol.apply(token, _toConsumableArray(symbol)) || token.isSpace();\n    }\n    function addGroup(tokens) {\n      var value = joinTokens$1(tokens);\n      if (option.verbose) {\n        if (lastGroupName.length || value.length) {\n          group.push({\n            group: lastGroupName,\n            value: value\n          });\n        }\n      } else {\n        group.push(value);\n      }\n    }\n    while (iter.next()) {\n      var _iter$get10 = iter.get(),\n        prev = _iter$get10.prev,\n        curr = _iter$get10.curr,\n        next = _iter$get10.next;\n      if (curr.isSymbol('(')) {\n        parenStack.push(curr.value);\n      }\n      if (curr.isSymbol(')')) {\n        parenStack.pop();\n      }\n      if (curr.status === 'open') {\n        quoteStack.push(curr.value);\n      }\n      if (curr.status === 'close') {\n        quoteStack.pop();\n      }\n      var emptyStack = !parenStack.length && !quoteStack.length;\n      if (emptyStack) {\n        var isNextSpace = option.noSpace && curr.isSpace() && isSeperator(next);\n        var isPrevSpace = option.noSpace && curr.isSpace() && isSeperator(prev);\n        if (isNextSpace || isPrevSpace) continue;\n      }\n      if (emptyStack && isSeperator(curr)) {\n        addGroup(tokens);\n        lastGroupName = curr.value;\n        tokens = [];\n      } else {\n        tokens.push(curr);\n      }\n    }\n    if (tokens.length) {\n      addGroup(tokens);\n    }\n    return group;\n  }\n  function joinTokens$1(tokens) {\n    return tokens.map(function (n) {\n      return n.value;\n    }).join('');\n  }\n  function readStatement$1(iter, token) {\n    var fragment = [];\n    var inlineBlock;\n    var stackQuote = [];\n    var stackParen = [];\n    while (iter.next()) {\n      var _iter$get11 = iter.get(),\n        curr = _iter$get11.curr,\n        next = _iter$get11.next;\n      if (curr.isSymbol('(') && !stackQuote.length) {\n        stackParen.push(curr);\n      } else if (curr.isSymbol(')') && !stackQuote.length) {\n        stackParen.pop();\n      }\n      var isStatementBreak = !stackQuote.length && !stackParen.length && (!next || curr.isSymbol(';') || next.isSymbol('}'));\n      if (curr.isSymbol(\"'\", '\"')) {\n        if (curr.status === 'open') {\n          stackQuote.push(curr);\n        } else {\n          stackQuote.pop();\n        }\n        if (next && next.isSymbol('}') && !stackQuote.length) {\n          isStatementBreak = true;\n        }\n      }\n      if (!stackParen.length && !stackQuote.length && curr.isSymbol('{')) {\n        var selectors = getSelectors(fragment);\n        if (!selectors.length) {\n          continue;\n        }\n        var tokenName = selectors.pop();\n        var skip = isSkip.apply(void 0, _toConsumableArray(selectors).concat([tokenName]));\n        inlineBlock = resolveId(walk$1(iter, splitTimes(tokenName, {\n          type: 'block',\n          inline: true,\n          name: tokenName,\n          value: []\n        })), skip);\n        while (tokenName = selectors.pop()) {\n          inlineBlock = resolveId(splitTimes(tokenName, {\n            type: 'block',\n            name: tokenName,\n            value: [inlineBlock]\n          }), skip);\n        }\n        break;\n      }\n      fragment.push(curr);\n      if (isStatementBreak) {\n        break;\n      }\n    }\n    if (fragment.length && !inlineBlock) {\n      token._valueTokens = fragment;\n      token.value = joinToken$2(fragment);\n    } else if (inlineBlock) {\n      token.value = inlineBlock;\n    }\n    if (token.origin) {\n      token.origin.value = token.value;\n    }\n    return token;\n  }\n  function readStyle(iter) {\n    var stack = [];\n    var style = [];\n    while (iter.next()) {\n      var _iter$get12 = iter.get(),\n        curr = _iter$get12.curr;\n      if (curr.isSymbol('{')) {\n        stack.push(curr.value);\n      } else if (curr.isSymbol('}')) {\n        if (stack.length) {\n          stack.pop();\n        } else {\n          break;\n        }\n      }\n      style.push(curr.value);\n    }\n    return style.join('');\n  }\n  function walk$1(iter, parentToken) {\n    var rules = [];\n    var fragment = [];\n    var tokenType = parentToken && parentToken.type || '';\n    var stack = [];\n    var _loop = function _loop() {\n      var _iter$get13 = iter.get(),\n        prev = _iter$get13.prev,\n        curr = _iter$get13.curr,\n        next = _iter$get13.next;\n      if (curr.isSymbol('(')) {\n        stack.push(curr.value);\n      }\n      if (curr.isSymbol(')')) {\n        stack.pop();\n      }\n      var isBlockBreak = !next || curr.isSymbol('}');\n      if (isBlock(tokenType) && isBlockBreak) {\n        if (!next && rules.length && !curr.isSymbol('}')) {\n          var _last = rules[rules.length - 1].value;\n          if (typeof _last === 'string') {\n            rules[rules.length - 1].value += ';' + curr.value;\n          }\n        }\n        parentToken.value = rules;\n        return \"break\";\n      } else if (curr.isSymbol('{')) {\n        var selectors = getSelectors(fragment);\n        if (!selectors.length) {\n          return \"continue\";\n        }\n        if (isSkip(parentToken.name)) {\n          selectors = [joinToken$2(fragment)];\n        }\n        var tokenName = selectors.pop();\n        var skip = isSkip.apply(void 0, _toConsumableArray(selectors).concat([parentToken.name, tokenName]));\n        if (tokenName === 'style') {\n          rules.push({\n            type: 'block',\n            name: tokenName,\n            value: readStyle(iter)\n          });\n        } else {\n          var block = resolveId(walk$1(iter, splitTimes(tokenName, {\n            type: 'block',\n            name: tokenName,\n            value: []\n          })), skip);\n          while (tokenName = selectors.pop()) {\n            block = resolveId(splitTimes(tokenName, {\n              type: 'block',\n              name: tokenName,\n              value: [block]\n            }), skip);\n          }\n          rules.push(block);\n        }\n        fragment = [];\n      } else if (curr.isSymbol(':') && !stack.length && !isSpecialProperty(prev, next) && fragment.length) {\n        var props = getGroups(fragment, function (token) {\n          return token.isSymbol(',');\n        });\n        var intial = {\n          type: 'statement',\n          name: 'unkown',\n          value: ''\n        };\n        if (props.length > 1) {\n          intial.origin = {\n            name: props\n          };\n        }\n        var statement = readStatement$1(iter, intial);\n        var groupdValue = parse$8(statement.value);\n        var _expand = props.length > 1 && groupdValue.length === props.length;\n        props.forEach(function (prop, i) {\n          var item = Object.assign({}, statement, {\n            name: prop\n          });\n          if (/^\\-\\-/.test(prop)) {\n            item.variable = true;\n          }\n          if (_expand) {\n            item.value = groupdValue[i];\n          }\n          if (/viewBox/i.test(prop)) {\n            item.detail = parseViewBox(item.value, item._valueTokens);\n          }\n          delete item._valueTokens;\n          rules.push(item);\n        });\n        if (isBlock(tokenType)) {\n          parentToken.value = rules;\n        }\n        fragment = [];\n      } else if (curr.isSymbol(';')) {\n        if (rules.length && fragment.length) {\n          rules[rules.length - 1].value += ';' + joinToken$2(fragment);\n          fragment = [];\n        }\n      } else {\n        fragment.push(curr);\n      }\n    };\n    while (iter.next()) {\n      var _ret = _loop();\n      if (_ret === \"break\") break;\n      if (_ret === \"continue\") continue;\n    }\n    if (rules.length && isBlock(tokenType)) {\n      parentToken.value = rules;\n    }\n    return tokenType ? parentToken : rules;\n  }\n  function isSpecialProperty(prev, next) {\n    var names = ['xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'];\n    var prevValue = prev && prev.value;\n    var nextValue = next && next.value;\n    return names.includes(prevValue + ':' + nextValue);\n  }\n  function joinToken$2(tokens) {\n    return tokens.filter(function (token, i) {\n      if (token.isSymbol(';', '}') && i === tokens.length - 1) return false;\n      return true;\n    }).map(function (n) {\n      return n.value;\n    }).join('');\n  }\n  function resolveId(block, skip) {\n    var name = block.name || '';\n    var _name$split = name.split(/#/),\n      _name$split2 = _toArray(_name$split),\n      tokenName = _name$split2[0],\n      ids = _name$split2.slice(1);\n    var id = ids[ids.length - 1];\n    if (tokenName && id && !skip) {\n      block.name = tokenName;\n      block.value.push({\n        type: 'statement',\n        name: 'id',\n        value: id\n      });\n    }\n    return block;\n  }\n  function getGroups(tokens, fn) {\n    var group = [];\n    var temp = [];\n    tokens.forEach(function (token) {\n      if (fn(token)) {\n        group.push(joinToken$2(temp));\n        temp = [];\n      } else {\n        temp.push(token);\n      }\n    });\n    if (temp.length) {\n      group.push(joinToken$2(temp));\n    }\n    return group;\n  }\n  function getSelectors(tokens) {\n    var result = [];\n    var it = iterator$1(tokens);\n    var hasSymbol;\n    while (it.next()) {\n      var _it$get = it.get(),\n        prev = _it$get.prev,\n        curr = _it$get.curr,\n        next = _it$get.next;\n      var isTimeSymbol = prev && next && curr.value === 'x' && prev.isNumber() && next.isNumber();\n      if (curr.isWord() && !hasSymbol && !isTimeSymbol) {\n        result.push(curr.value.trim());\n      } else {\n        result[result.length - 1] = (result[result.length - 1] + curr.value).trim();\n      }\n      if (curr.isSymbol()) {\n        hasSymbol = true;\n      } else if (!curr.isSpace()) {\n        hasSymbol = false;\n      }\n    }\n    return result;\n  }\n  function parseViewBox(value, tokens) {\n    var viewBox = {\n      value: []\n    };\n    var temp;\n    if (!Array.isArray(tokens)) {\n      return viewBox;\n    }\n    var _iterator = _createForOfIteratorHelper(tokens),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var token = _step.value;\n        if (token.isSpace() || token.isSymbol(',', ';')) {\n          continue;\n        }\n        if (viewBox.value.length < 4 && token.isNumber()) {\n          viewBox.value.push(Number(token.value));\n        } else if (token.isNumber() && temp) {\n          viewBox[temp] = Number(token.value);\n          temp = null;\n        } else if (token.isWord()) {\n          temp = token.value;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return viewBox;\n  }\n  function splitTimes(name, object) {\n    var target = Object.assign({}, object);\n    if (/\\*\\s*[0-9]/.test(name)) {\n      var _name$split3 = name.split('*'),\n        _name$split4 = _slicedToArray(_name$split3, 2),\n        tokenName = _name$split4[0],\n        times = _name$split4[1];\n      if (times) {\n        target.times = times.trim();\n        target.pureName = tokenName.trim();\n      }\n    }\n    return target;\n  }\n  function isSkip() {\n    for (var _len4 = arguments.length, names = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      names[_key4] = arguments[_key4];\n    }\n    return names.some(function (n) {\n      return n === 'style';\n    });\n  }\n  function isBlock(type) {\n    return type === 'block';\n  }\n  function skipHeadSVG(block) {\n    var headSVG,\n      headVariables = [];\n    var _iterator2 = _createForOfIteratorHelper(block.value),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var item = _step2.value;\n        if (item.name === 'svg') {\n          headSVG = item;\n        }\n        if (item.variable) {\n          headVariables.push(item);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    if (headSVG) {\n      var _headSVG$value;\n      (_headSVG$value = headSVG.value).push.apply(_headSVG$value, headVariables);\n      return headSVG;\n    }\n    return block;\n  }\n  function parse$7(source, root) {\n    var iter = iterator$1(scan(source));\n    var tokens = walk$1(iter, root || {\n      type: 'block',\n      name: 'svg',\n      value: []\n    });\n    return skipHeadSVG(tokens);\n  }\n  function generate$2(token, last) {\n    var result = '';\n    if (token.type === 'block') {\n      var isInline = Array.isArray(token.value) && token.value[0] && token.value[0].inline;\n      if (token.times) {\n        result += '@M' + token.times + '(' + token.pureName + '{';\n      } else {\n        result += token.name + (isInline ? ' ' : '{');\n      }\n      if (token.name === 'style') {\n        result += token.value;\n      } else if (Array.isArray(token.value) && token.value.length) {\n        var lastGroup = '';\n        var _iterator3 = _createForOfIteratorHelper(token.value),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var t = _step3.value;\n            result += generate$2(t, lastGroup);\n            if (t.origin) {\n              lastGroup = t.origin.name.join(',');\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      if (token.times) {\n        result += '})';\n      } else if (!isInline) {\n        result += '}';\n      }\n    } else if (token.type === 'statement') {\n      var skip = token.origin && last === token.origin.name.join(',');\n      var name = token.origin ? token.origin.name.join(',') : token.name;\n      var value = token.origin ? token.origin.value : token.value;\n      if (!skip) {\n        result += value && value.type ? name + ':' + generate$2(value) : name + ':' + value + ';';\n      }\n    }\n    return result;\n  }\n  function generate_svg_extended(token) {\n    return generate$2(token).trim();\n  }\n  function make_array(arr) {\n    if (is_nil(arr)) return [];\n    return Array.isArray(arr) ? arr : [arr];\n  }\n  function join(arr) {\n    var spliter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '\\n';\n    return (arr || []).join(spliter);\n  }\n  function last(arr) {\n    var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    if (is_nil(arr)) return '';\n    return arr[arr.length - n];\n  }\n  function first(arr) {\n    return arr[0];\n  }\n  function clone(arr) {\n    return JSON.parse(JSON.stringify(arr));\n  }\n  function duplicate(arr) {\n    return [].concat(arr, arr);\n  }\n  function flat_map(arr, fn) {\n    if (Array.prototype.flatMap) return arr.flatMap(fn);\n    return arr.reduce(function (acc, x) {\n      return acc.concat(fn(x));\n    }, []);\n  }\n  function remove_empty_values(arr) {\n    return arr.filter(function (v) {\n      return !is_nil(v) && String(v).trim().length;\n    });\n  }\n\n  // I need to rewrite this\n\n  var Tokens = {\n    func: function func() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return {\n        type: 'func',\n        name: name,\n        arguments: []\n      };\n    },\n    argument: function argument() {\n      return {\n        type: 'argument',\n        value: []\n      };\n    },\n    text: function text() {\n      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return {\n        type: 'text',\n        value: value\n      };\n    },\n    pseudo: function pseudo() {\n      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return {\n        type: 'pseudo',\n        selector: selector,\n        styles: []\n      };\n    },\n    cond: function cond() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return {\n        type: 'cond',\n        name: name,\n        styles: [],\n        arguments: []\n      };\n    },\n    rule: function rule() {\n      var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return {\n        type: 'rule',\n        property: property,\n        value: []\n      };\n    },\n    keyframes: function keyframes() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return {\n        type: 'keyframes',\n        name: name,\n        steps: []\n      };\n    },\n    step: function step() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return {\n        type: 'step',\n        name: name,\n        styles: []\n      };\n    }\n  };\n  var is = {\n    white_space: function white_space(c) {\n      return /[\\s\\n\\t]/.test(c);\n    },\n    line_break: function line_break(c) {\n      return /\\n/.test(c);\n    },\n    number: function number(n) {\n      return !isNaN(n);\n    },\n    pair: function pair(n) {\n      return ['\"', '(', ')', \"'\"].includes(n);\n    },\n    pair_of: function pair_of(c, n) {\n      return {\n        '\"': '\"',\n        \"'\": \"'\",\n        '(': ')'\n      }[c] == n;\n    }\n  };\n\n  // This should not be in the parser\n  // but I'll leave it here until the rewriting\n  var symbols = {\n    'π': Math.PI,\n    '∏': Math.PI\n  };\n  function composible(name) {\n    return /^@(canvas|shaders|doodle)/.test(name);\n  }\n  function iterator() {\n    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var _index = 0,\n      col = 1,\n      line = 1;\n    return {\n      curr: function curr() {\n        var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        return input[_index + n];\n      },\n      end: function end() {\n        return input.length <= _index;\n      },\n      info: function info() {\n        return {\n          index: _index,\n          col: col,\n          line: line\n        };\n      },\n      index: function index(n) {\n        return n === undefined ? _index : _index = n;\n      },\n      range: function range(start, end) {\n        return input.substring(start, end);\n      },\n      next: function next() {\n        var next = input[_index++];\n        if (next == '\\n') line++, col = 0;else col++;\n        return next;\n      }\n    };\n  }\n  function throw_error(msg, _ref4) {\n    var col = _ref4.col,\n      line = _ref4.line;\n    console.warn(\"(at line \".concat(line, \", column \").concat(col, \") \").concat(msg));\n  }\n  function get_text_value(input) {\n    if (input.trim().length) {\n      return is.number(+input) ? +input : input.trim();\n    } else {\n      return input;\n    }\n  }\n  function read_until(fn) {\n    return function (it, reset) {\n      var index = it.index();\n      var word = '';\n      while (!it.end()) {\n        var c = it.next();\n        if (fn(c)) break;else word += c;\n      }\n      if (reset) {\n        it.index(index);\n      }\n      return word;\n    };\n  }\n  function read_word(it, reset) {\n    var check = function check(c) {\n      return /[^\\w@]/.test(c);\n    };\n    return read_until(check)(it, reset);\n  }\n  function read_keyframe_name(it) {\n    return read_until(function (c) {\n      return /[\\s\\{]/.test(c);\n    })(it);\n  }\n  function read_line(it, reset) {\n    var check = function check(c) {\n      return is.line_break(c) || c == '{';\n    };\n    return read_until(check)(it, reset);\n  }\n  function read_step(it, extra) {\n    var c,\n      step = Tokens.step();\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      } else if (!step.name.length) {\n        step.name = read_selector(it);\n      } else {\n        step.styles.push(read_rule(it, extra));\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return step;\n  }\n  function read_steps(it, extra) {\n    var steps = [];\n    var c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;else if (is.white_space(c)) {\n        it.next();\n        continue;\n      } else {\n        steps.push(read_step(it, extra));\n      }\n      it.next();\n    }\n    return steps;\n  }\n  function read_keyframes(it, extra) {\n    var keyframes = Tokens.keyframes(),\n      c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '}') break;else if (!keyframes.name.length) {\n        read_word(it);\n        keyframes.name = read_keyframe_name(it);\n        if (!keyframes.name.length) {\n          throw_error('missing keyframes name', it.info());\n          break;\n        }\n        continue;\n      } else if (c == '{' || it.curr(-1) == '{') {\n        it.next();\n        keyframes.steps = read_steps(it, extra);\n        break;\n      }\n      it.next();\n    }\n    return keyframes;\n  }\n  function read_comments(it) {\n    var flag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    it.next();\n    while (!it.end()) {\n      var c = it.curr();\n      if (flag.inline) {\n        if (c == '\\n') break;\n      } else {\n        if ((c = it.curr()) == '*' && it.curr(1) == '/') break;\n      }\n      it.next();\n    }\n    if (!flag.inline) {\n      it.next();\n      it.next();\n    }\n  }\n  function skip_tag(it) {\n    it.next();\n    while (!it.end()) {\n      var c = it.curr();\n      if (c == '>') break;\n      it.next();\n    }\n  }\n  function read_property(it) {\n    var prop = '',\n      c;\n    while (!it.end()) {\n      if ((c = it.curr()) == ':') break;else if (!is.white_space(c)) prop += c;\n      it.next();\n    }\n    return prop;\n  }\n  function read_arguments(it, composition, doodle) {\n    var args = [],\n      group = [],\n      stack = [],\n      arg = '',\n      c;\n    var raw = '';\n    while (!it.end()) {\n      c = it.curr();\n      var prev = it.curr(-1);\n      var start = it.index();\n      if (/[\\('\"`]/.test(c) && prev !== '\\\\') {\n        if (stack.length) {\n          if (c !== '(' && last(stack) === '(') {\n            stack.pop();\n          }\n          if (c != '(' && c === last(stack)) {\n            stack.pop();\n          } else {\n            stack.push(c);\n          }\n        } else {\n          stack.push(c);\n        }\n        arg += c;\n      } else if ((c == '@' || prev === '.' && composition) && !doodle) {\n        if (!group.length) {\n          arg = arg.trimLeft();\n        }\n        if (arg.length) {\n          group.push(Tokens.text(arg));\n          arg = '';\n        }\n        group.push(read_func(it));\n      } else if (doodle && /[)]/.test(c) || !doodle && /[,)]/.test(c)) {\n        if (stack.length) {\n          if (c == ')' && last(stack) === '(') {\n            stack.pop();\n          }\n          arg += c;\n        } else {\n          if (arg.length) {\n            if (!group.length) {\n              group.push(Tokens.text(get_text_value(arg)));\n            } else if (/\\S/.test(arg)) {\n              group.push(Tokens.text(arg));\n            }\n            if (arg.startsWith('±') && !doodle) {\n              var _raw = arg.substr(1);\n              var cloned = clone(group);\n              last(cloned).value = '-' + _raw;\n              args.push(normalize_argument(cloned));\n              last(group).value = _raw;\n            }\n          }\n          args.push(normalize_argument(group));\n          group = [];\n          arg = '';\n          if (c == ')') break;\n        }\n      } else {\n        if (symbols[c] && !/[0-9]/.test(it.curr(-1))) {\n          c = symbols[c];\n        }\n        arg += c;\n      }\n      if (composition && (it.curr(1) == ')' || it.curr(1) == ';' || !/[0-9a-zA-Z_\\-.]/.test(it.curr())) && !stack.length) {\n        if (group.length) {\n          args.push(normalize_argument(group));\n        }\n        break;\n      } else {\n        raw += it.range(start, it.index() + 1);\n        it.next();\n      }\n    }\n    return [skip_last_empty_args(args), raw];\n  }\n  function skip_last_empty_args(args) {\n    var arg = last(args[0]);\n    if (arg && arg.type === 'text' && !String(arg.value).trim().length) {\n      args[0] = args[0].slice(0, -1);\n    }\n    return args;\n  }\n  function normalize_argument(group) {\n    var result = group.map(function (arg) {\n      if (arg.type == 'text' && typeof arg.value == 'string') {\n        var value = String(arg.value);\n        if (value.includes('`')) {\n          arg.value = value = value.replace(/`/g, '\"');\n        }\n        arg.value = value;\n      }\n      return arg;\n    });\n    var ft = first(result) || {};\n    var ed = last(result) || {};\n    if (ft.type == 'text' && ed.type == 'text') {\n      var cf = first(ft.value);\n      var ce = last(ed.value);\n      if (typeof ft.value == 'string' && typeof ed.value == 'string') {\n        if (is.pair_of(cf, ce)) {\n          ft.value = ft.value.slice(1);\n          ed.value = ed.value.slice(0, ed.value.length - 1);\n          result.cluster = true;\n        }\n      }\n    }\n    return result;\n  }\n  function seperate_func_name(name) {\n    var fname = '',\n      extra = '';\n    if (/\\D$/.test(name) && !/\\d+[x-]\\d+/.test(name) || Math[name.substr(1)]) {\n      return {\n        fname: name,\n        extra: extra\n      };\n    }\n    for (var i = name.length - 1; i >= 0; i--) {\n      var c = name[i];\n      var prev = name[i - 1];\n      var next = name[i + 1];\n      if (/[\\d.]/.test(c) || (c == 'x' || c == '-') && /\\d/.test(prev) && /\\d/.test(next)) {\n        extra = c + extra;\n      } else {\n        fname = name.substring(0, i + 1);\n        break;\n      }\n    }\n    return {\n      fname: fname,\n      extra: extra\n    };\n  }\n  function has_times_syntax(token) {\n    var str = JSON.stringify(token);\n    return str.includes('pureName') && str.includes('times');\n  }\n  function is_svg(name) {\n    return /^@svg$/i.test(name);\n  }\n  function read_func(it) {\n    var func = Tokens.func();\n    var name = it.curr(),\n      c;\n    var has_argument = false;\n    if (name === '@') {\n      it.next();\n    } else {\n      name = '@';\n    }\n    while (!it.end()) {\n      c = it.curr();\n      var next = it.curr(1);\n      var composition = c == '.' && (next == '@' || /[a-zA-Z]/.test(next));\n      if (c == '(' || composition) {\n        has_argument = true;\n        it.next();\n        var _read_arguments = read_arguments(it, composition, composible(name)),\n          _read_arguments2 = _slicedToArray(_read_arguments, 2),\n          args = _read_arguments2[0],\n          raw_args = _read_arguments2[1];\n        if (is_svg(name) && /\\d\\s*{/.test(raw_args)) {\n          var parsed_svg = parse$7(raw_args);\n          if (has_times_syntax(parsed_svg)) {\n            var svg = generate_svg_extended(parsed_svg);\n            // compatible with old iterator\n            svg += ')';\n            var extended = read_arguments(iterator(svg), composition, composible(name));\n            args = extended[0];\n          }\n        }\n        func.arguments = args;\n        break;\n      } else if (/[0-9a-zA-Z_\\-.]/.test(c)) {\n        name += c;\n      }\n      if (!has_argument && next !== '(' && !/[0-9a-zA-Z_\\-.]/.test(next)) {\n        break;\n      }\n      it.next();\n    }\n    var _seperate_func_name = seperate_func_name(name),\n      fname = _seperate_func_name.fname,\n      extra = _seperate_func_name.extra;\n    func.name = fname;\n    if (extra.length) {\n      func.arguments.unshift([{\n        type: 'text',\n        value: extra\n      }]);\n    }\n    func.position = it.info().index;\n    return func;\n  }\n  function read_value(it) {\n    var text = Tokens.text(),\n      idx = 0,\n      skip = true,\n      c;\n    var value = [];\n    value[idx] = [];\n    var stack = [],\n      quote_stack = [];\n    while (!it.end()) {\n      c = it.curr();\n      if (skip && is.white_space(c)) {\n        it.next();\n        continue;\n      } else {\n        skip = false;\n      }\n      if (c == '\\n' && !is.white_space(it.curr(-1))) {\n        text.value += ' ';\n      } else if (c == ',' && !stack.length) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        value[++idx] = [];\n        skip = true;\n      } else if (/[;}<]/.test(c) && !quote_stack.length) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        break;\n      } else if (c == '@' && /\\w/.test(it.curr(1))) {\n        if (text.value.length) {\n          value[idx].push(text);\n          text = Tokens.text();\n        }\n        value[idx].push(read_func(it));\n      } else if (c === '\"' || c === \"'\") {\n        var quote = last(quote_stack);\n        if (c === quote) {\n          quote_stack.pop();\n        } else if (!quote_stack.length) {\n          quote_stack.push(c);\n        }\n        text.value += c;\n      } else if (!is.white_space(c) || !is.white_space(it.curr(-1))) {\n        if (c == '(') stack.push(c);\n        if (c == ')') stack.pop();\n        if (symbols[c] && !/[0-9]/.test(it.curr(-1))) {\n          c = symbols[c];\n        }\n        text.value += c;\n      }\n      if (it.curr() === ';' || it.curr() == '}') {\n        break;\n      }\n      it.next();\n    }\n    if (text.value.length) {\n      value[idx].push(text);\n    }\n    return value;\n  }\n  function read_selector(it) {\n    var selector = '',\n      c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '{') break;else if (!is.white_space(c)) {\n        selector += c;\n      }\n      it.next();\n    }\n    return selector;\n  }\n  function read_cond_selector(it) {\n    var selector = {\n        name: '',\n        arguments: []\n      },\n      c;\n    while (!it.end()) {\n      if ((c = it.curr()) == '(') {\n        it.next();\n        selector.arguments = read_arguments(it)[0];\n      } else if (/[){]/.test(c)) break;else if (!is.white_space(c)) selector.name += c;\n      it.next();\n    }\n    return selector;\n  }\n  function read_pseudo(it, extra) {\n    var pseudo = Tokens.pseudo(),\n      c;\n    while (!it.end()) {\n      c = it.curr();\n      if (c == '/' && it.curr(1) == '*') {\n        read_comments(it);\n      } else if (c == '}') {\n        break;\n      } else if (is.white_space(c)) {\n        it.next();\n        continue;\n      } else if (!pseudo.selector) {\n        pseudo.selector = read_selector(it);\n      } else {\n        var rule = read_rule(it, extra);\n        if (rule.property == '@use') {\n          pseudo.styles = pseudo.styles.concat(rule.value);\n        } else {\n          pseudo.styles.push(rule);\n        }\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return pseudo;\n  }\n  function read_rule(it, extra) {\n    var rule = Tokens.rule(),\n      c;\n    var start = it.index();\n    while (!it.end()) {\n      c = it.curr();\n      if (c == '/' && it.curr(1) == '*') {\n        read_comments(it);\n      } else if (c == ';') {\n        break;\n      } else if (!rule.property.length) {\n        rule.property = read_property(it);\n        if (rule.property == '@use') {\n          rule.value = read_var(it, extra);\n          break;\n        }\n      } else {\n        rule.value = read_value(it);\n        break;\n      }\n      it.next();\n    }\n    var end = it.index();\n    rule.raw = function () {\n      return it.range(start, end).trim();\n    };\n    return rule;\n  }\n  function read_cond(it, extra) {\n    var cond = Tokens.cond(),\n      c;\n    while (!it.end()) {\n      c = it.curr();\n      if (c == '/' && it.curr(1) == '*') {\n        read_comments(it);\n      } else if (c == '}') {\n        break;\n      } else if (!cond.name.length) {\n        Object.assign(cond, read_cond_selector(it));\n      } else if (c == ':') {\n        var pseudo = read_pseudo(it);\n        if (pseudo.selector) cond.styles.push(pseudo);\n      } else if (c == '@' && !read_line(it, true).includes(':')) {\n        cond.styles.push(read_cond(it));\n      } else if (!is.white_space(c)) {\n        var rule = read_rule(it, extra);\n        if (rule.property) cond.styles.push(rule);\n        if (it.curr() == '}') break;\n      }\n      it.next();\n    }\n    return cond;\n  }\n  function read_variable(extra, name) {\n    var rule = '';\n    if (extra && extra.get_variable) {\n      rule = extra.get_variable(name);\n    }\n    return rule;\n  }\n  function evaluate_value(values, extra) {\n    values.forEach && values.forEach(function (v) {\n      if (v.type == 'text' && v.value) {\n        var vars = parse$9(v.value);\n        v.value = vars.reduce(function (ret, p) {\n          var rule = '',\n            other = '',\n            parsed;\n          rule = read_variable(extra, p.name);\n          if (!rule && p.fallback) {\n            p.fallback.every(function (n) {\n              other = read_variable(extra, n.name);\n              if (other) {\n                rule = other;\n                return false;\n              }\n            });\n          }\n          try {\n            parsed = parse$6(rule, extra);\n          } catch (e) {}\n          if (parsed) {\n            ret.push.apply(ret, parsed);\n          }\n          return ret;\n        }, []);\n      }\n      if (v.type == 'func' && v.arguments) {\n        v.arguments.forEach(function (arg) {\n          evaluate_value(arg, extra);\n        });\n      }\n    });\n  }\n  function read_var(it, extra) {\n    it.next();\n    var groups = read_value(it) || [];\n    return groups.reduce(function (ret, group) {\n      evaluate_value(group, extra);\n      var _group = _slicedToArray(group, 1),\n        token = _group[0];\n      if (token.value && token.value.length) {\n        ret.push.apply(ret, _toConsumableArray(token.value));\n      }\n      return ret;\n    }, []);\n  }\n  function parse$6(input, extra) {\n    var it = iterator(input);\n    var Tokens = [];\n    while (!it.end()) {\n      var c = it.curr();\n      if (is.white_space(c)) {\n        it.next();\n        continue;\n      } else if (c == '/' && it.curr(1) == '*') {\n        read_comments(it);\n      } else if (c == ':') {\n        var pseudo = read_pseudo(it, extra);\n        if (pseudo.selector) Tokens.push(pseudo);\n      } else if (c == '@' && read_word(it, true) === '@keyframes') {\n        var keyframes = read_keyframes(it, extra);\n        Tokens.push(keyframes);\n      } else if (c == '@' && !read_line(it, true).includes(':')) {\n        var cond = read_cond(it, extra);\n        if (cond.name.length) Tokens.push(cond);\n      } else if (c == '<') {\n        skip_tag(it);\n      } else if (!is.white_space(c)) {\n        var rule = read_rule(it, extra);\n        if (rule.property) Tokens.push(rule);\n      }\n      it.next();\n    }\n    return Tokens;\n  }\n  function parse_grid(size) {\n    var GRID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;\n    var min = 1,\n      max = GRID,\n      total = GRID * GRID;\n    var _replace$replace$spli = (size + '').replace(/\\s+/g, '').replace(/[,，xX]+/g, 'x').split('x').map(function (n) {\n        return parseInt(n);\n      }),\n      _replace$replace$spli2 = _slicedToArray(_replace$replace$spli, 3),\n      x = _replace$replace$spli2[0],\n      y = _replace$replace$spli2[1],\n      z = _replace$replace$spli2[2];\n    var max_xy = x == 1 || y == 1 ? total : max;\n    var max_z = x == 1 && y == 1 ? total : min;\n    var ret = {\n      x: clamp(x || min, 1, max_xy),\n      y: clamp(y || x || min, 1, max_xy),\n      z: clamp(z || min, 1, max_z)\n    };\n    return Object.assign({}, ret, {\n      count: ret.x * ret.y * ret.z,\n      ratio: ret.x / ret.y\n    });\n  }\n  function parse$5(input) {\n    var scanOptions = {\n      preserveLineBreak: true,\n      ignoreInlineComment: true\n    };\n    var iter = iterator$1(removeParens(scan(input, scanOptions)));\n    var stack = [];\n    var tokens = [];\n    var identifier;\n    var line;\n    var result = {\n      textures: []\n    };\n    while (iter.next()) {\n      var _iter$get14 = iter.get(),\n        curr = _iter$get14.curr,\n        next = _iter$get14.next;\n      if (curr.isSymbol('{')) {\n        if (!stack.length) {\n          var name = joinToken$1(tokens);\n          if (isIdentifier(name)) {\n            identifier = name;\n            tokens = [];\n          } else {\n            tokens.push(curr);\n          }\n        } else {\n          tokens.push(curr);\n        }\n        stack.push('{');\n      } else if (curr.isSymbol('}')) {\n        stack.pop();\n        if (!stack.length && identifier) {\n          var value = joinToken$1(tokens);\n          if (identifier && value.length) {\n            if (identifier.startsWith('texture')) {\n              result.textures.push({\n                name: identifier,\n                value: value\n              });\n            } else {\n              result[identifier] = value;\n            }\n            tokens = [];\n          }\n          identifier = null;\n        } else {\n          tokens.push(curr);\n        }\n      } else {\n        if (!is_empty(line) && line != curr.pos[1]) {\n          tokens.push(lineBreak());\n          line = null;\n        }\n        if (!identifier || !identifier.startsWith('texture')) {\n          if (curr.isWord() && curr.value.startsWith('#')) {\n            tokens.push(lineBreak());\n            line = next.pos[1];\n          }\n        }\n        tokens.push(curr);\n      }\n    }\n    if (is_empty(result.fragment)) {\n      result.fragment = joinToken$1(tokens);\n      result.textures = result.textures || [];\n    }\n    return result;\n  }\n  function isIdentifier(name) {\n    return /^texture\\w*$|^(fragment|vertex)$/.test(name);\n  }\n  function lineBreak() {\n    return new Token({\n      type: 'LineBreak',\n      value: '\\n'\n    });\n  }\n  function removeParens(tokens) {\n    var head = tokens[0];\n    var last = tokens[tokens.length - 1];\n    while (head && head.isSymbol('(') && last && last.isSymbol(')')) {\n      tokens = tokens.slice(1, tokens.length - 1);\n      head = tokens[0];\n      last = tokens[tokens.length - 1];\n    }\n    return tokens;\n  }\n  function joinToken$1(tokens) {\n    return removeParens(tokens).map(function (n) {\n      return n.value;\n    }).join('');\n  }\n  var NS$1 = 'http://www.w3.org/2000/svg';\n  var NSXLink$1 = 'http://www.w3.org/1999/xlink';\n  function create_svg_url(svg, id) {\n    var encoded = encodeURIComponent(svg) + (id ? \"#\".concat(id) : '');\n    return \"url(\\\"data:image/svg+xml;utf8,\".concat(encoded, \"\\\")\");\n  }\n  function normalize_svg(input) {\n    var xmlns = \"xmlns=\\\"\".concat(NS$1, \"\\\"\");\n    var xmlnsXLink = \"xmlns:xlink=\\\"\".concat(NSXLink$1, \"\\\"\");\n    if (!input.includes('<svg')) {\n      input = \"<svg \".concat(xmlns, \" \").concat(xmlnsXLink, \">\").concat(input, \"</svg>\");\n    }\n    if (!input.includes('xmlns')) {\n      input = input.replace(/<svg([\\s>])/, \"<svg \".concat(xmlns, \" \").concat(xmlnsXLink, \"$1\"));\n    }\n    return input;\n  }\n  var NS = 'http://www.w3.org/2000/svg';\n  var NSXLink = 'http://www.w3.org/1999/xlink';\n  var nextId$1 = next_id();\n  var Tag = /*#__PURE__*/function () {\n    function Tag(name) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      _classCallCheck(this, Tag);\n      if (!name) {\n        throw new Error(\"Tag name is required\");\n      }\n      this.name = name;\n      this.body = [];\n      this.attrs = {};\n      if (this.isTextNode()) {\n        this.body = value;\n      }\n    }\n    _createClass(Tag, [{\n      key: \"isTextNode\",\n      value: function isTextNode() {\n        return this.name === 'text-node';\n      }\n    }, {\n      key: \"find\",\n      value: function find(target) {\n        var id = target.attrs.id;\n        var name = target.name;\n        if (Array.isArray(this.body) && id !== undefined) {\n          return this.body.find(function (tag) {\n            return tag.attrs.id === id && tag.name === name;\n          });\n        }\n      }\n    }, {\n      key: \"append\",\n      value: function append(tag) {\n        if (!this.isTextNode()) {\n          this.body.push(tag);\n        }\n      }\n    }, {\n      key: \"merge\",\n      value: function merge(tag) {\n        for (var _i5 = 0, _Object$entries2 = Object.entries(tag.attrs); _i5 < _Object$entries2.length; _i5++) {\n          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i5], 2),\n            name = _Object$entries2$_i[0],\n            value = _Object$entries2$_i[1];\n          this.attrs[name] = value;\n        }\n        if (Array.isArray(tag.body)) {\n          var _this$body;\n          (_this$body = this.body).push.apply(_this$body, _toConsumableArray(tag.body));\n        }\n      }\n    }, {\n      key: \"attr\",\n      value: function attr(name, value) {\n        if (!this.isTextNode()) {\n          if (value === undefined) {\n            return this.attrs[name];\n          }\n          return this.attrs[name] = value;\n        }\n      }\n    }, {\n      key: \"toString\",\n      value: function toString() {\n        if (this.isTextNode()) {\n          return removeQuotes(this.body);\n        }\n        var attrs = [''];\n        var body = [];\n        for (var _i6 = 0, _Object$entries3 = Object.entries(this.attrs); _i6 < _Object$entries3.length; _i6++) {\n          var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i6], 2),\n            name = _Object$entries3$_i[0],\n            value = _Object$entries3$_i[1];\n          value = removeQuotes(value);\n          attrs.push(\"\".concat(name, \"=\\\"\").concat(value, \"\\\"\"));\n        }\n        var _iterator4 = _createForOfIteratorHelper(this.body),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var tag = _step4.value;\n            body.push(tag.toString());\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n        return \"<\".concat(this.name).concat(attrs.join(' '), \">\").concat(body.join(''), \"</\").concat(this.name, \">\");\n      }\n    }]);\n    return Tag;\n  }();\n  function composeStyleRule(name, value) {\n    return \"\".concat(name, \":\").concat(value, \";\");\n  }\n  function removeQuotes(text) {\n    text = String(text);\n    var double = text.startsWith('\"') && text.endsWith('\"');\n    var single = text.startsWith(\"'\") && text.endsWith(\"'\");\n    if (double || single) {\n      return text.substring(1, text.length - 1);\n    }\n    return text;\n  }\n  function transformViewBox(token) {\n    var viewBox = token.detail.value;\n    var p = token.detail.padding || token.detail.expand;\n    if (!viewBox.length) {\n      return '';\n    }\n    var _viewBox = _slicedToArray(viewBox, 4),\n      x = _viewBox[0],\n      y = _viewBox[1],\n      w = _viewBox[2],\n      h = _viewBox[3];\n    if (p) {\n      var _ref5 = [x - p, x - p, w + p * 2, h + p * 2];\n      x = _ref5[0];\n      y = _ref5[1];\n      w = _ref5[2];\n      h = _ref5[3];\n    }\n    return \"\".concat(x, \" \").concat(y, \" \").concat(w, \" \").concat(h);\n  }\n  function generate$1(token, element, parent, root) {\n    var inlineId;\n    if (!element) {\n      element = new Tag('root');\n    }\n    if (token.type === 'block') {\n      // style tag\n      if (token.name === 'style') {\n        var el = new Tag('style');\n        el.append(token.value);\n        element.append(el);\n      }\n      // normal svg elements\n      else {\n        var _el = new Tag(token.name);\n        if (!root) {\n          root = _el;\n          root.attr('xmlns', NS);\n        }\n        var _iterator5 = _createForOfIteratorHelper(token.value),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var block = _step5.value;\n            var id = generate$1(block, _el, token, root);\n            if (id) {\n              inlineId = id;\n            }\n          }\n          // generate id for inline block if no id is found\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        if (token.inline) {\n          var found = token.value.find(function (n) {\n            return n.type === 'statement' && n.name === 'id';\n          });\n          if (found) {\n            inlineId = found.value;\n          } else {\n            inlineId = nextId$1(token.name);\n            _el.attr('id', inlineId);\n          }\n        }\n        var existedTag = root.find(_el);\n        if (existedTag) {\n          existedTag.merge(_el);\n        } else {\n          element.append(_el);\n        }\n      }\n    }\n    if (token.type === 'statement' && !token.variable) {\n      if (token.name === 'content') {\n        var text = new Tag('text-node', token.value);\n        element.append(text);\n      }\n      // inline style\n      else if (token.name.startsWith('style ')) {\n        var name = (token.name.split('style ')[1] || '').trim();\n        if (name.length) {\n          var style = element.attr('style') || '';\n          element.attr('style', style + composeStyleRule(name, token.value));\n        }\n      } else {\n        var value = token.value;\n        // handle inline block value\n        if (value && value.type === 'block') {\n          var _id = generate$1(token.value, root, token, root);\n          value = \"url(#\".concat(_id, \")\");\n          if (token.name === 'xlink:href' || token.name === 'href') {\n            value = \"#\".concat(_id);\n          }\n        }\n        if (/viewBox/i.test(token.name)) {\n          value = transformViewBox(token);\n          if (value) {\n            element.attr(token.name, value);\n          }\n        } else {\n          element.attr(token.name, value);\n        }\n        if (token.name.includes('xlink:')) {\n          root.attr('xmlns:xlink', NSXLink);\n        }\n      }\n    }\n    if (!parent) {\n      return root.toString();\n    }\n    return inlineId;\n  }\n  function generate_svg(token) {\n    return generate$1(token);\n  }\n  function parse$4(input) {\n    var iter = iterator$1(scan(input));\n    var ret = {};\n    var matched = false;\n    while (iter.next()) {\n      var _iter$get15 = iter.get(),\n        prev = _iter$get15.prev,\n        curr = _iter$get15.curr,\n        next = _iter$get15.next;\n      var isUnit = matched && (curr.isWord() || curr.isSymbol()) && prev && prev.isNumber() && !next;\n      if (curr.isNumber()) {\n        ret.value = Number(curr.value);\n        matched = true;\n      } else if (isUnit) {\n        ret.unit = curr.value;\n      } else {\n        break;\n      }\n    }\n    return ret;\n  }\n  function by_unit(fn) {\n    return function () {\n      var units = [],\n        values = [];\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      for (var _i7 = 0, _args = args; _i7 < _args.length; _i7++) {\n        var arg = _args[_i7];\n        var _parse$ = parse$4(arg),\n          _unit = _parse$.unit,\n          value = _parse$.value;\n        if (_unit !== undefined) {\n          units.push(_unit);\n        }\n        if (value !== undefined) {\n          values.push(value);\n        }\n      }\n      var result = fn.apply(void 0, values);\n      var unit = units.find(function (n) {\n        return n !== undefined;\n      });\n      if (unit === undefined) {\n        return result;\n      }\n      if (Array.isArray(result)) {\n        return result.map(function (n) {\n          return n + unit;\n        });\n      }\n      return result + unit;\n    };\n  }\n  function by_charcode(fn) {\n    return function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      var codes = args.map(function (n) {\n        return String(n).charCodeAt(0);\n      });\n      var result = fn.apply(void 0, _toConsumableArray(codes));\n      return Array.isArray(result) ? result.map(function (n) {\n        return String.fromCharCode(n);\n      }) : String.fromCharCode(result);\n    };\n  }\n\n  /**\n   * Based on the Shunting-yard algorithm.\n   */\n\n  var default_context = {\n    'π': Math.PI,\n    gcd: function gcd(a, b) {\n      while (b) {\n        var _ref6 = [b, a % b];\n        a = _ref6[0];\n        b = _ref6[1];\n      }\n      return a;\n    }\n  };\n  var operator = {\n    '^': 7,\n    '*': 6,\n    '/': 6,\n    '÷': 6,\n    '%': 6,\n    '&': 5,\n    '|': 5,\n    '+': 4,\n    '-': 4,\n    '<': 3,\n    '<<': 3,\n    '>': 3,\n    '>>': 3,\n    '=': 3,\n    '==': 3,\n    '≤': 3,\n    '<=': 3,\n    '≥': 3,\n    '>=': 3,\n    '≠': 3,\n    '!=': 3,\n    '∧': 2,\n    '&&': 2,\n    '∨': 2,\n    '||': 2,\n    '(': 1,\n    ')': 1\n  };\n  function calc(expr, context) {\n    var repeat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var stack = [];\n    while (expr.length) {\n      var _expr$shift = expr.shift(),\n        name = _expr$shift.name,\n        value = _expr$shift.value,\n        type = _expr$shift.type;\n      if (type === 'variable') {\n        var result = context[value];\n        if (is_invalid_number(result)) {\n          result = Math[value];\n        }\n        if (is_invalid_number(result)) {\n          result = expand$1(value, context);\n        }\n        if (is_invalid_number(result)) {\n          if (/^\\-\\D/.test(value)) {\n            result = expand$1('-1' + value.substr(1), context);\n          }\n        }\n        if (result === undefined) {\n          result = 0;\n        }\n        if (typeof result !== 'number') {\n          repeat.push(result);\n          if (is_cycle(repeat)) {\n            result = 0;\n            repeat = [];\n          } else {\n            result = calc(infix_to_postfix(result), context, repeat);\n          }\n        }\n        stack.push(result);\n      } else if (type === 'function') {\n        var negative = false;\n        if (/^\\-/.test(name)) {\n          negative = true;\n          name = name.substr(1);\n        }\n        var output = value.map(function (v) {\n          return calc(v, context);\n        });\n        var fns = name.split('.');\n        var fname = void 0;\n        while (fname = fns.pop()) {\n          if (!fname) continue;\n          var fn = context[fname] || Math[fname];\n          output = typeof fn === 'function' ? Array.isArray(output) ? fn.apply(void 0, _toConsumableArray(output)) : fn(output) : 0;\n        }\n        if (negative) {\n          output = -1 * output;\n        }\n        stack.push(output);\n      } else {\n        if (/\\d+/.test(value)) stack.push(value);else {\n          var right = stack.pop();\n          var left = stack.pop();\n          stack.push(compute(value, Number(left), Number(right)));\n        }\n      }\n    }\n    return Number(stack[0]) || 0;\n  }\n  function get_tokens$1(input) {\n    var expr = String(input);\n    var tokens = [],\n      num = '';\n    for (var i = 0; i < expr.length; ++i) {\n      var c = expr[i];\n      if (operator[c]) {\n        var last_token = last(tokens);\n        if (c == '=' && last_token && /^[!<>=]$/.test(last_token.value)) {\n          last_token.value += c;\n        } else if (/^[|&<>]$/.test(c) && last_token && last_token.value == c) {\n          last_token.value += c;\n        } else if (c == '-' && expr[i - 1] == 'e') {\n          num += c;\n        } else if (!tokens.length && !num.length && /[+-]/.test(c)) {\n          num += c;\n        } else {\n          var _ref7 = last_token || {},\n            type = _ref7.type,\n            value = _ref7.value;\n          if (type == 'operator' && !num.length && /[^()]/.test(c) && /[^()]/.test(value)) {\n            num += c;\n          } else {\n            if (num.length) {\n              tokens.push({\n                type: 'number',\n                value: num\n              });\n              num = '';\n            }\n            tokens.push({\n              type: 'operator',\n              value: c\n            });\n          }\n        }\n      } else if (/\\S/.test(c)) {\n        if (c == ',') {\n          tokens.push({\n            type: 'number',\n            value: num\n          });\n          num = '';\n          tokens.push({\n            type: 'comma',\n            value: c\n          });\n        } else if (c == '!') {\n          tokens.push({\n            type: 'number',\n            value: num\n          });\n          tokens.push({\n            type: 'operator',\n            value: c\n          });\n          num = '';\n        } else {\n          num += c;\n        }\n      }\n    }\n    if (num.length) {\n      tokens.push({\n        type: 'number',\n        value: num\n      });\n    }\n    return tokens;\n  }\n  function infix_to_postfix(input) {\n    var tokens = get_tokens$1(input);\n    var op_stack = [],\n      expr = [];\n    for (var i = 0; i < tokens.length; ++i) {\n      var _tokens$i = tokens[i],\n        type = _tokens$i.type,\n        value = _tokens$i.value;\n      var next = tokens[i + 1] || {};\n      if (type == 'number') {\n        if (next.value == '(' && /[^\\d.\\-]/.test(value)) {\n          var func_body = '';\n          var stack = [];\n          var values = [];\n          i += 1;\n          while (tokens[i++] !== undefined) {\n            var token = tokens[i];\n            if (token === undefined) break;\n            var c = token.value;\n            if (c == ')') {\n              if (!stack.length) break;\n              stack.pop();\n              func_body += c;\n            } else {\n              if (c == '(') stack.push(c);\n              if (c == ',' && !stack.length) {\n                var arg = infix_to_postfix(func_body);\n                if (arg.length) values.push(arg);\n                func_body = '';\n              } else {\n                func_body += c;\n              }\n            }\n          }\n          if (func_body.length) {\n            values.push(infix_to_postfix(func_body));\n          }\n          expr.push({\n            type: 'function',\n            name: value,\n            value: values\n          });\n        } else if (/[^\\d.\\-]/.test(value)) {\n          expr.push({\n            type: 'variable',\n            value: value\n          });\n        } else {\n          expr.push({\n            type: 'number',\n            value: value\n          });\n        }\n      } else if (type == 'operator') {\n        if (value == '(') {\n          op_stack.push(value);\n        } else if (value == ')') {\n          while (op_stack.length && last(op_stack) != '(') {\n            expr.push({\n              type: 'operator',\n              value: op_stack.pop()\n            });\n          }\n          op_stack.pop();\n        } else {\n          while (op_stack.length && operator[last(op_stack)] >= operator[value]) {\n            var op = op_stack.pop();\n            if (!/[()]/.test(op)) expr.push({\n              type: 'operator',\n              value: op\n            });\n          }\n          op_stack.push(value);\n        }\n      }\n    }\n    while (op_stack.length) {\n      expr.push({\n        type: 'operator',\n        value: op_stack.pop()\n      });\n    }\n    return expr;\n  }\n  function compute(op, a, b) {\n    switch (op) {\n      case '+':\n        return a + b;\n      case '-':\n        return a - b;\n      case '*':\n        return a * b;\n      case '%':\n        return a % b;\n      case '|':\n        return a | b;\n      case '&':\n        return a & b;\n      case '<':\n        return a < b;\n      case '>':\n        return a > b;\n      case '^':\n        return Math.pow(a, b);\n      case '÷':\n      case '/':\n        return a / b;\n      case '=':\n      case '==':\n        return a == b;\n      case '≤':\n      case '<=':\n        return a <= b;\n      case '≥':\n      case '>=':\n        return a >= b;\n      case '≠':\n      case '!=':\n        return a != b;\n      case '∧':\n      case '&&':\n        return a && b;\n      case '∨':\n      case '||':\n        return a || b;\n      case '<<':\n        return a << b;\n      case '>>':\n        return a >> b;\n    }\n  }\n  function expand$1(value, context) {\n    var _ref8 = value.match(/([\\d.\\-]+)(.*)/) || [],\n      _ref9 = _slicedToArray(_ref8, 3),\n      _ = _ref9[0],\n      num = _ref9[1],\n      variable = _ref9[2];\n    var v = context[variable];\n    if (v === undefined) {\n      return v;\n    }\n    if (typeof v === 'number') {\n      return Number(num) * v;\n    } else {\n      return num * calc(infix_to_postfix(v), context);\n    }\n  }\n  function is_cycle(array) {\n    return array[0] == array[2] && array[1] == array[3];\n  }\n  function calc$1(input, context) {\n    var expr = infix_to_postfix(input);\n    return calc(expr, Object.assign({}, default_context, context));\n  }\n  var CacheValue = /*#__PURE__*/function () {\n    function CacheValue() {\n      _classCallCheck(this, CacheValue);\n      this.cache = {};\n    }\n    _createClass(CacheValue, [{\n      key: \"clear\",\n      value: function clear() {\n        this.cache = {};\n      }\n    }, {\n      key: \"set\",\n      value: function set(input, value) {\n        if (is_nil(input)) {\n          return '';\n        }\n        var key = this.getKey(input);\n        return this.cache[key] = value;\n      }\n    }, {\n      key: \"get\",\n      value: function get(input) {\n        var key = this.getKey(input);\n        return this.cache[key];\n      }\n    }, {\n      key: \"getKey\",\n      value: function getKey(input) {\n        return typeof input === 'string' ? hash(input) : hash(JSON.stringify(input));\n      }\n    }]);\n    return CacheValue;\n  }();\n  var Cache = new CacheValue();\n  function memo(prefix, fn) {\n    return function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      var key = prefix + args.join('-');\n      return Cache.get(key) || Cache.set(key, fn.apply(void 0, args));\n    };\n  }\n  function Type(type, value) {\n    return {\n      type: type,\n      value: value\n    };\n  }\n  function get_tokens(input) {\n    var expr = String(input);\n    var tokens = [],\n      stack = [];\n    if (!expr.startsWith('[') || !expr.endsWith(']')) {\n      return tokens;\n    }\n    for (var i = 1; i < expr.length - 1; ++i) {\n      var c = expr[i];\n      if (c == '-' && expr[i - 1] == '-') {\n        continue;\n      }\n      if (c == '-') {\n        stack.push(c);\n        continue;\n      }\n      if (last(stack) == '-') {\n        stack.pop();\n        var from = stack.pop();\n        tokens.push(from ? Type('range', [from, c]) : Type('char', c));\n        continue;\n      }\n      if (stack.length) {\n        tokens.push(Type('char', stack.pop()));\n      }\n      stack.push(c);\n    }\n    if (stack.length) {\n      tokens.push(Type('char', stack.pop()));\n    }\n    return tokens;\n  }\n  var build_range = memo('build_range', function (input) {\n    var tokens = get_tokens(input);\n    return flat_map(tokens, function (_ref10) {\n      var type = _ref10.type,\n        value = _ref10.value;\n      if (type == 'char') return value;\n      var _value = _slicedToArray(value, 2),\n        from = _value[0],\n        to = _value[1];\n      var reverse = false;\n      if (from > to) {\n        var _ref11 = [to, from];\n        from = _ref11[0];\n        to = _ref11[1];\n        reverse = true;\n      }\n      var result = by_charcode(range)(from, to);\n      if (reverse) result.reverse();\n      return result;\n    });\n  });\n  function expand(fn) {\n    return function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return fn.apply(void 0, _toConsumableArray(flat_map(args, function (n) {\n        return String(n).startsWith('[') ? build_range(n) : n;\n      })));\n    };\n  }\n  var Node = function Node(data) {\n    _classCallCheck(this, Node);\n    this.prev = this.next = null;\n    this.data = data;\n  };\n  var Stack = /*#__PURE__*/function () {\n    function Stack() {\n      var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;\n      _classCallCheck(this, Stack);\n      this._limit = limit;\n      this._size = 0;\n    }\n    _createClass(Stack, [{\n      key: \"push\",\n      value: function push(data) {\n        if (this._size >= this._limit) {\n          this.root = this.root.next;\n          this.root.prev = null;\n        }\n        var node = new Node(data);\n        if (!this.root) {\n          this.root = this.tail = node;\n        } else {\n          node.prev = this.tail;\n          this.tail.next = node;\n          this.tail = node;\n        }\n        this._size++;\n      }\n    }, {\n      key: \"last\",\n      value: function last() {\n        var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        var node = this.tail;\n        while (--n) {\n          if (!node.prev) break;\n          node = node.prev;\n        }\n        return node.data;\n      }\n    }]);\n    return Stack;\n  }();\n  /**\n   * Improved noise by Ken Perlin\n   * Translated from: https://mrl.nyu.edu/~perlin/noise/\n   */\n  var Perlin = /*#__PURE__*/function () {\n    function Perlin() {\n      _classCallCheck(this, Perlin);\n      this.p = duplicate([151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]);\n    }\n\n    // Convert LO 4 bits of hash code into 12 gradient directions.\n    _createClass(Perlin, [{\n      key: \"grad\",\n      value: function grad(hash, x, y, z) {\n        var h = hash & 15,\n          u = h < 8 ? x : y,\n          v = h < 4 ? y : h == 12 || h == 14 ? x : z;\n        return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n      }\n    }, {\n      key: \"noise\",\n      value: function noise(x, y, z) {\n        var p = this.p,\n          grad = this.grad; // Find unit cube that contains point.\n        var _map = [x, y, z].map(function (n) {\n            return Math.floor(n) & 255;\n          }),\n          _map2 = _slicedToArray(_map, 3),\n          X = _map2[0],\n          Y = _map2[1],\n          Z = _map2[2]; // Find relative x, y, z of point in cube.\n        var _map3 = [x, y, z].map(function (n) {\n          return n - Math.floor(n);\n        });\n        var _map4 = _slicedToArray(_map3, 3);\n        x = _map4[0];\n        y = _map4[1];\n        z = _map4[2];\n        // Compute fade curves for each of x, y, z.\n        var _map5 = [x, y, z].map(function (n) {\n            return n * n * n * (n * (n * 6 - 15) + 10);\n          }),\n          _map6 = _slicedToArray(_map5, 3),\n          u = _map6[0],\n          v = _map6[1],\n          w = _map6[2]; // hash coordinates of the 8 cube corners.\n        var A = p[X] + Y,\n          AA = p[A] + Z,\n          AB = p[A + 1] + Z,\n          B = p[X + 1] + Y,\n          BA = p[B] + Z,\n          BB = p[B + 1] + Z;\n        // And add blended results from 8 corners of cube.\n        return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), grad(p[BA], x - 1, y, z)), lerp(u, grad(p[AB], x, y - 1, z), grad(p[BB], x - 1, y - 1, z))), lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1), grad(p[BA + 1], x - 1, y, z - 1)), lerp(u, grad(p[AB + 1], x, y - 1, z - 1), grad(p[BB + 1], x - 1, y - 1, z - 1))));\n      }\n    }]);\n    return Perlin;\n  }();\n  function get_named_arguments(args, names) {\n    var result = {};\n    var order = true;\n    for (var i = 0; i < args.length; ++i) {\n      var arg = args[i];\n      var arg_name = names[i];\n      if (/=/.test(arg)) {\n        var _parse$2 = parse$8(arg, {\n            symbol: '=',\n            noSpace: true\n          }),\n          _parse$3 = _slicedToArray(_parse$2, 2),\n          name = _parse$3[0],\n          value = _parse$3[1];\n        if (value !== undefined) {\n          if (names.includes(name)) {\n            result[name] = value;\n          }\n          // ignore the rest unnamed arguments\n          order = false;\n        } else {\n          result[arg_name] = arg;\n        }\n      } else if (order) {\n        result[arg_name] = arg;\n      }\n    }\n    return result;\n  }\n  function parse$3(input) {\n    var iter = iterator$1(scan(input));\n    var commands = {};\n    var tokens = [];\n    var name;\n    var negative = false;\n    while (iter.next()) {\n      var _iter$get16 = iter.get(),\n        prev = _iter$get16.prev,\n        curr = _iter$get16.curr,\n        next = _iter$get16.next;\n      if (curr.isSymbol(':') && !name) {\n        name = joinTokens(tokens);\n        tokens = [];\n      } else if (curr.isSymbol(';') && name) {\n        commands[name] = transformNegative(name, joinTokens(tokens), negative);\n        tokens = [];\n        name = null;\n        negative = false;\n      } else if (!curr.isSymbol(';')) {\n        var prevMinus = prev && prev.isSymbol('-');\n        var nextMinus = next && next.isSymbol('-');\n        var currMinus = curr.isSymbol('-');\n        if (!name && !tokens.length && currMinus && !prevMinus && !nextMinus) {\n          if (next && next.isSymbol(':')) {\n            tokens.push(curr);\n          } else {\n            negative = true;\n          }\n        } else {\n          tokens.push(curr);\n        }\n      }\n    }\n    if (tokens.length && name) {\n      commands[name] = transformNegative(name, joinTokens(tokens), negative);\n    }\n    return commands;\n  }\n  function transformNegative(name, value, negative) {\n    var excludes = ['fill-rule', 'fill'];\n    if (excludes.includes(name)) {\n      return value;\n    }\n    return negative ? \"-1 * (\".concat(value, \")\") : value;\n  }\n  function joinTokens(tokens) {\n    return tokens.map(function (n) {\n      return n.value;\n    }).join('');\n  }\n  var keywords = ['auto', 'reverse'];\n  var units = ['deg', 'rad', 'grad', 'turn'];\n  function parse$2(input) {\n    var iter = iterator$1(scan(input));\n    var matched = false;\n    var unit = '';\n    var ret = {\n      direction: '',\n      angle: ''\n    };\n    while (iter.next()) {\n      var _iter$get17 = iter.get(),\n        prev = _iter$get17.prev,\n        curr = _iter$get17.curr,\n        next = _iter$get17.next;\n      if (curr.isWord() && keywords.includes(curr.value)) {\n        ret.direction = curr.value;\n        matched = true;\n      } else if (curr.isNumber()) {\n        ret.angle = Number(curr.value);\n        matched = true;\n      } else if (curr.isWord() && prev && prev.isNumber() && units.includes(curr.value)) {\n        unit = curr.value;\n      } else if (curr.isSpace() && ret.direction !== '' && ret.angle !== '') {\n        break;\n      }\n    }\n    if (!matched) {\n      ret.direction = 'auto';\n    }\n    return normalizeAngle(ret, unit);\n  }\n  function normalizeAngle(input, unit) {\n    var angle = input.angle;\n    if (angle === '') {\n      angle = 0;\n    }\n    if (unit === 'rad') {\n      angle /= Math.PI / 180;\n    }\n    if (unit === 'grad') {\n      angle *= .9;\n    }\n    if (unit === 'turn') {\n      angle *= 360;\n    }\n    return Object.assign({}, input, {\n      angle: angle\n    });\n  }\n  var cos = Math.cos,\n    sin = Math.sin,\n    abs = Math.abs,\n    atan2 = Math.atan2,\n    PI = Math.PI;\n  var _ = make_tag_function(function (c) {\n    return create_shape_points(parse$3(c), {\n      min: 3,\n      max: 3600\n    });\n  });\n  var shapes = {\n    circle: function circle() {\n      return _(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n    split: 180;\\n    scale: .99\\n  \"])));\n    },\n    triangle: function triangle() {\n      return _(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\n    rotate: 30;\\n    scale: 1.1;\\n    move: 0 .2\\n  \"])));\n    },\n    pentagon: function pentagon() {\n      return _(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\\n    split: 5;\\n    rotate: 54\\n  \"])));\n    },\n    hexagon: function hexagon() {\n      return _(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\\n    split: 6;\\n    rotate: 30;\\n    scale: .98\\n  \"])));\n    },\n    octagon: function octagon() {\n      return _(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\\n    split: 8;\\n    rotat: 22.5;\\n    scale: .99\\n  \"])));\n    },\n    star: function star() {\n      return _(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\\n    split: 10;\\n    r: cos(5t);\\n    rotate: -18;\\n    scale: .99\\n  \"])));\n    },\n    infinity: function infinity() {\n      return _(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\\n    split: 180;\\n    scale: .99;\\n    x: cos(t)*.99 / (sin(t)^2 + 1);\\n    y: x * sin(t)\\n  \"])));\n    },\n    heart: function heart() {\n      return _(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\\n    split: 180;\\n    rotate: 180;\\n    a: cos(t)*13/18 - cos(2t)*5/18;\\n    b: cos(3t)/18 + cos(4t)/18;\\n    x: (.75 * sin(t)^3) * 1.2;\\n    y: (a - b + .2) * -1.1\\n  \"])));\n    },\n    bean: function bean() {\n      return _(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\\n    split: 180;\\n    r: sin(t)^3 + cos(t)^3;\\n    move: -.35 .35;\\n  \"])));\n    },\n    bicorn: function bicorn() {\n      return _(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\\n    split: 180;\\n    x: cos(t);\\n    y: sin(t)^2 / (2 + sin(t)) - .5\\n  \"])));\n    },\n    drop: function drop() {\n      return _(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\\n    split: 180;\\n    rotate: 90;\\n    scale: .95;\\n    x: sin(t);\\n    y: (1 + sin(t)) * cos(t) / 1.6\\n  \"])));\n    },\n    fish: function fish() {\n      return _(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"\\n    split: 240;\\n    x: cos(t) - sin(t)^2 / sqrt(2) - .04;\\n    y: sin(2t)/2\\n  \"])));\n    },\n    whale: function whale() {\n      return _(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"\\n    split: 240;\\n    rotate: 180;\\n    R: 3.4 * (sin(t)^2 - .5) * cos(t);\\n    x: cos(t) * R + .75;\\n    y: sin(t) * R * 1.2\\n  \"])));\n    },\n    windmill: function windmill() {\n      return _(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\\n    split: 18;\\n    R: seq(.618, 1, 0);\\n    T: seq(t-.55, t, t);\\n    x: R * cos(T);\\n    y: R * sin(T)\\n  \"])));\n    },\n    vase: function vase() {\n      return _(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"\\n    split: 240;\\n    scale: .3;\\n    x: sin(4t) + sin(t) * 1.4;\\n    y: cos(t) + cos(t) * 4.8 + .3\\n  \"])));\n    },\n    clover: function clover() {\n      var k = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n      k = clamp(k, 3, 5);\n      if (k == 4) k = 2;\n      return _(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\\n      split: 240;\\n      r: cos(\", \"t);\\n      scale: .98\\n    \"])), k);\n    },\n    hypocycloid: function hypocycloid() {\n      var k = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n      k = clamp(k, 3, 5);\n      var scale = [0, 0, 0, .34, .25, .19][k];\n      return _(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"\\n      split: 240;\\n      scale: \", \";\\n      k: \", \";\\n      x: (k-1)*cos(t) + cos((k-1)*t);\\n      y: (k-1)*sin(t) - sin((k-1)*t)\\n    \"])), scale, k);\n    },\n    bud: function bud() {\n      var k = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n      k = clamp(k, 3, 10);\n      return _(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral([\"\\n      split: 240;\\n      scale: .8;\\n      r: 1 + .2 * cos(\", \"t)\\n    \"])), k);\n    }\n  };\n  var Point = /*#__PURE__*/function () {\n    function Point(x, y, angle) {\n      _classCallCheck(this, Point);\n      this.x = x;\n      this.y = y;\n      this.extra = angle;\n    }\n    _createClass(Point, [{\n      key: \"valueOf\",\n      value: function valueOf() {\n        return this.x + ' ' + this.y;\n      }\n    }, {\n      key: \"toString\",\n      value: function toString() {\n        return this.valueOf();\n      }\n    }]);\n    return Point;\n  }();\n  function create_polygon_points(option, fn) {\n    if (typeof arguments[0] == 'function') {\n      fn = option;\n      option = {};\n    }\n    if (!fn) {\n      fn = function fn(t) {\n        return [cos(t), sin(t)];\n      };\n    }\n    var split = option.split || 180;\n    var turn = option.turn || 1;\n    var frame = option.frame;\n    var fill = option['fill'] || option['fill-rule'];\n    var direction = parse$2(option['direction'] || option['dir'] || '');\n    var unit = option.unit;\n    var rad = PI * 2 * turn / split;\n    var points = [];\n    var first_point, first_point2;\n    var factor = option.scale === undefined ? 1 : option.scale;\n    var add = function add(_ref12) {\n      var _ref13 = _slicedToArray(_ref12, 4),\n        x1 = _ref13[0],\n        y1 = _ref13[1],\n        _ref13$ = _ref13[2],\n        dx = _ref13$ === void 0 ? 0 : _ref13$,\n        _ref13$2 = _ref13[3],\n        dy = _ref13$2 === void 0 ? 0 : _ref13$2;\n      if (x1 == 'evenodd' || x1 == 'nonzero') {\n        return points.push(new Point(x1, '', ''));\n      }\n      var _scale = scale(x1, -y1, factor),\n        _scale2 = _slicedToArray(_scale, 2),\n        x = _scale2[0],\n        y = _scale2[1];\n      var _scale3 = scale(dx, -dy, factor),\n        _scale4 = _slicedToArray(_scale3, 2),\n        dx1 = _scale4[0],\n        dy2 = _scale4[1];\n      var angle = calc_angle(x, y, dx1, dy2, direction);\n      if (unit !== undefined && unit !== '%') {\n        if (unit !== 'none') {\n          x += unit;\n          y += unit;\n        }\n      } else {\n        x = (x + 1) * 50 + '%';\n        y = (y + 1) * 50 + '%';\n      }\n      points.push(new Point(x, y, angle));\n    };\n    if (fill == 'nonzero' || fill == 'evenodd') {\n      add([fill, '', '']);\n    }\n    for (var i = 0; i < split; ++i) {\n      var t = rad * i;\n      var point = fn(t, i);\n      if (!i) first_point = point;\n      add(point);\n    }\n    if (frame !== undefined) {\n      add(first_point);\n      var w = frame / 100;\n      if (turn > 1) w *= 2;\n      if (w == 0) w = .002;\n      for (var _i8 = 0; _i8 < split; ++_i8) {\n        var _t = -rad * _i8;\n        var _fn2 = fn(_t, _i8),\n          _fn3 = _slicedToArray(_fn2, 4),\n          x = _fn3[0],\n          y = _fn3[1],\n          _fn3$ = _fn3[2],\n          dx = _fn3$ === void 0 ? 0 : _fn3$,\n          _fn3$2 = _fn3[3],\n          dy = _fn3$2 === void 0 ? 0 : _fn3$2;\n        var theta = atan2(y + dy, x - dx);\n        var _point = [x - w * cos(theta), y - w * sin(theta)];\n        if (!_i8) first_point2 = _point;\n        add(_point);\n      }\n      add(first_point2);\n      add(first_point);\n    }\n    return points;\n  }\n  function calc_angle(x, y, dx, dy, option) {\n    var base = atan2(y + dy, x - dx) * 180 / PI;\n    if (option.direction === 'reverse') {\n      base -= 180;\n    }\n    if (!option.direction) {\n      base = 90;\n    }\n    if (option.angle) {\n      base += option.angle;\n    }\n    return base;\n  }\n  function rotate(x, y, deg) {\n    var rad = -PI / 180 * deg;\n    return [x * cos(rad) - y * sin(rad), y * cos(rad) + x * sin(rad)];\n  }\n  function translate(x, y, offset) {\n    var _parse$8$map = parse$8(offset).map(Number),\n      _parse$8$map2 = _slicedToArray(_parse$8$map, 2),\n      dx = _parse$8$map2[0],\n      _parse$8$map2$ = _parse$8$map2[1],\n      dy = _parse$8$map2$ === void 0 ? dx : _parse$8$map2$;\n    return [x + (dx || 0), y - (dy || 0), dx, dy];\n  }\n  function scale(x, y, factor) {\n    var _parse$8$map3 = parse$8(factor).map(Number),\n      _parse$8$map4 = _slicedToArray(_parse$8$map3, 2),\n      fx = _parse$8$map4[0],\n      _parse$8$map4$ = _parse$8$map4[1],\n      fy = _parse$8$map4$ === void 0 ? fx : _parse$8$map4$;\n    return [x * fx, y * fy];\n  }\n  function create_shape_points(props, _ref14) {\n    var min = _ref14.min,\n      max = _ref14.max;\n    var split = clamp(parseInt(props.vertices || props.points || props.split) || 0, min, max);\n    var px = is_empty(props.x) ? 'cos(t)' : props.x;\n    var py = is_empty(props.y) ? 'sin(t)' : props.y;\n    var pr = is_empty(props.r) ? '' : props.r;\n    var _parse$4 = parse$4(pr),\n      unit = _parse$4.unit,\n      value = _parse$4.value;\n    if (unit && !props[unit] && unit !== 't') {\n      if (is_empty(props.unit)) {\n        props.unit = unit;\n      }\n      pr = props.r = value;\n    }\n    if (props.degree) {\n      props.rotate = props.degree;\n    }\n    if (props.origin) {\n      props.move = props.origin;\n    }\n    var option = Object.assign({}, props, {\n      split: split\n    });\n    return create_polygon_points(option, function (t, i) {\n      var context = Object.assign({}, props, {\n        't': t,\n        'θ': t,\n        'i': i + 1,\n        seq: function seq() {\n          var _ref15;\n          if (!arguments.length) return '';\n          return _ref15 = i % arguments.length, _ref15 < 0 || arguments.length <= _ref15 ? undefined : arguments[_ref15];\n        },\n        range: function range(a) {\n          var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          a = Number(a) || 0;\n          b = Number(b) || 0;\n          if (a > b) {\n            var _ref16 = [b, a];\n            a = _ref16[0];\n            b = _ref16[1];\n          }\n          var step = abs(b - a) / (split - 1);\n          return a + step * i;\n        }\n      });\n      var x = calc$1(px, context);\n      var y = calc$1(py, context);\n      var dx = 0;\n      var dy = 0;\n      if (pr) {\n        var r = calc$1(pr, context);\n        if (r == 0) {\n          r = .00001;\n        }\n        x = r * cos(t);\n        y = r * sin(t);\n      }\n      if (props.rotate) {\n        var _rotate = rotate(x, y, Number(props.rotate) || 0);\n        var _rotate2 = _slicedToArray(_rotate, 2);\n        x = _rotate2[0];\n        y = _rotate2[1];\n      }\n      if (props.move) {\n        var _translate = translate(x, y, props.move);\n        var _translate2 = _slicedToArray(_translate, 4);\n        x = _translate2[0];\n        y = _translate2[1];\n        dx = _translate2[2];\n        dy = _translate2[3];\n      }\n      return [x, y, dx, dy];\n    });\n  }\n  var commands = 'MmLlHhVvCcSsQqTtAaZz';\n  var relatives = 'mlhvcsqtaz';\n  function parse$1(input) {\n    var iter = iterator$1(scan(input));\n    var temp = {};\n    var result = {\n      commands: [],\n      valid: true\n    };\n    while (iter.next()) {\n      var _iter$get18 = iter.get(),\n        curr = _iter$get18.curr;\n      if (curr.isSpace() || curr.isSymbol(',')) {\n        continue;\n      }\n      if (curr.isWord()) {\n        if (temp.name) {\n          result.commands.push(temp);\n          temp = {};\n        }\n        temp.name = curr.value;\n        temp.value = [];\n        if (!commands.includes(curr.value)) {\n          temp.type = 'unknown';\n          result.valid = false;\n        } else if (relatives.includes(curr.value)) {\n          temp.type = 'relative';\n        } else {\n          temp.type = 'absolute';\n        }\n      } else if (temp.value) {\n        var value = curr.value;\n        if (curr.isNumber()) {\n          value = Number(curr.value);\n        }\n        temp.value.push(value);\n      } else if (!temp.name) {\n        result.valid = false;\n      }\n    }\n    if (temp.name) {\n      result.commands.push(temp);\n    }\n    return result;\n  }\n  var uniform_time = {\n    'name': 'cssd-uniform-time',\n    'animation-name': 'cssd-uniform-time-animation',\n    'animation-duration': 31536000000,\n    /* one year in ms */\n    'animation-iteration-count': 'infinite',\n    'animation-delay': '0s',\n    'animation-direction': 'normal',\n    'animation-fill-mode': 'none',\n    'animation-play-state': 'running',\n    'animation-timing-function': 'linear'\n  };\n  uniform_time['animation'] = \"\\n  \".concat(uniform_time['animation-duration'], \"ms\\n  \").concat(uniform_time['animation-timing-function'], \"\\n  \").concat(uniform_time['animation-delay'], \"\\n  \").concat(uniform_time['animation-iteration-count'], \"\\n  \").concat(uniform_time['animation-name'], \"\\n\");\n  var uniform_mousex = {\n    name: 'cssd-uniform-mousex'\n  };\n  var uniform_mousey = {\n    name: 'cssd-uniform-mousey'\n  };\n  var uniform_width = {\n    name: 'cssd-uniform-width'\n  };\n  var uniform_height = {\n    name: 'cssd-uniform-height'\n  };\n  var Uniforms = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    uniform_time: uniform_time,\n    uniform_mousex: uniform_mousex,\n    uniform_mousey: uniform_mousey,\n    uniform_width: uniform_width,\n    uniform_height: uniform_height\n  });\n  function make_sequence(c) {\n    return lazy(function (_, n) {\n      for (var _len9 = arguments.length, actions = new Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {\n        actions[_key9 - 2] = arguments[_key9];\n      }\n      if (!actions || !n) return '';\n      var count = get_value(n());\n      var evaluated = count;\n      if (/\\D/.test(count) && !/\\d+[x-]\\d+/.test(count)) {\n        evaluated = calc$1(count);\n        if (evaluated === 0) {\n          evaluated = count;\n        }\n      }\n      var signature = Math.random();\n      return sequence(evaluated, function () {\n        for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n          args[_key10] = arguments[_key10];\n        }\n        return actions.map(function (action) {\n          return get_value(action.apply(void 0, args.concat([signature])));\n        }).join(',');\n      }).join(c);\n    });\n  }\n  function push_stack(context, name, value) {\n    if (!context[name]) context[name] = new Stack();\n    context[name].push(value);\n    return value;\n  }\n  function flip_value(num) {\n    return -1 * num;\n  }\n  function map2d(value, min, max) {\n    var amp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var dimension = 2;\n    var v = Math.sqrt(dimension / 4) * amp;\n    var ma = -v,\n      mb = v;\n    return lerp((value - ma) / (mb - ma), min * amp, max * amp);\n  }\n  function calc_with(base) {\n    return function (v) {\n      if (is_empty(v) || is_empty(base)) {\n        return base;\n      }\n      if (/^[+*-\\/%][.\\d\\s]/.test(v)) {\n        var op = v[0];\n        var num = Number(v.substr(1).trim()) || 0;\n        switch (op) {\n          case '+':\n            return base + num;\n          case '-':\n            return base - num;\n          case '*':\n            return base * num;\n          case '/':\n            return base / num;\n          case '%':\n            return base % num;\n        }\n      } else if (/[+*-\\/%]$/.test(v)) {\n        var _op = v.substr(-1);\n        var _num3 = Number(v.substr(0, v.length - 1).trim()) || 0;\n        switch (_op) {\n          case '+':\n            return _num3 + base;\n          case '-':\n            return _num3 - base;\n          case '*':\n            return _num3 * base;\n          case '/':\n            return _num3 / base;\n          case '%':\n            return _num3 % base;\n        }\n      }\n      return base + (Number(v) || 0);\n    };\n  }\n  var Expose = add_alias({\n    i: function i(_ref17) {\n      var count = _ref17.count;\n      return calc_with(count);\n    },\n    y: function y(_ref18) {\n      var _y2 = _ref18.y;\n      return calc_with(_y2);\n    },\n    x: function x(_ref19) {\n      var _x2 = _ref19.x;\n      return calc_with(_x2);\n    },\n    z: function z(_ref20) {\n      var _z = _ref20.z;\n      return calc_with(_z);\n    },\n    I: function I(_ref21) {\n      var grid = _ref21.grid;\n      return calc_with(grid.count);\n    },\n    Y: function Y(_ref22) {\n      var grid = _ref22.grid;\n      return calc_with(grid.y);\n    },\n    X: function X(_ref23) {\n      var grid = _ref23.grid;\n      return calc_with(grid.x);\n    },\n    Z: function Z(_ref24) {\n      var grid = _ref24.grid;\n      return calc_with(grid.z);\n    },\n    id: function id(_ref25) {\n      var x = _ref25.x,\n        y = _ref25.y,\n        z = _ref25.z;\n      return function (_) {\n        return cell_id(x, y, z);\n      };\n    },\n    dx: function dx(_ref26) {\n      var x = _ref26.x,\n        grid = _ref26.grid;\n      return function (n) {\n        n = Number(n) || 0;\n        return x - .5 - n - grid.x / 2;\n      };\n    },\n    dy: function dy(_ref27) {\n      var y = _ref27.y,\n        grid = _ref27.grid;\n      return function (n) {\n        n = Number(n) || 0;\n        return y - .5 - n - grid.y / 2;\n      };\n    },\n    n: function n(_ref28) {\n      var extra = _ref28.extra;\n      var lastExtra = last(extra);\n      return lastExtra ? calc_with(lastExtra[0]) : '@n';\n    },\n    nx: function nx(_ref29) {\n      var extra = _ref29.extra;\n      var lastExtra = last(extra);\n      return lastExtra ? calc_with(lastExtra[1]) : '@nx';\n    },\n    ny: function ny(_ref30) {\n      var extra = _ref30.extra;\n      var lastExtra = last(extra);\n      return lastExtra ? calc_with(lastExtra[2]) : '@ny';\n    },\n    N: function N(_ref31) {\n      var extra = _ref31.extra;\n      var lastExtra = last(extra);\n      return lastExtra ? calc_with(lastExtra[3]) : '@N';\n    },\n    m: make_sequence(','),\n    M: make_sequence(' '),\n    µ: make_sequence(''),\n    p: function p(_ref32) {\n      var context = _ref32.context,\n        pick = _ref32.pick;\n      return expand(function () {\n        for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n          args[_key11] = arguments[_key11];\n        }\n        if (!args.length) {\n          args = context.last_pick_args || [];\n        }\n        var picked = pick(args);\n        context.last_pick_args = args;\n        return push_stack(context, 'last_pick', picked);\n      });\n    },\n    P: function P(_ref33) {\n      var context = _ref33.context,\n        pick = _ref33.pick,\n        position = _ref33.position;\n      var counter = 'P-counter' + position;\n      return expand(function () {\n        for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n          args[_key12] = arguments[_key12];\n        }\n        var normal = true;\n        if (!args.length) {\n          args = context.last_pick_args || [];\n          normal = false;\n        }\n        var stack = context.last_pick;\n        var last = stack ? stack.last(1) : '';\n        if (normal) {\n          if (!context[counter]) {\n            context[counter] = {};\n          }\n          last = context[counter].last_pick;\n        }\n        if (args.length > 1) {\n          var i = args.findIndex(function (n) {\n            return n === last;\n          });\n          if (i !== -1) {\n            args.splice(i, 1);\n          }\n        }\n        var picked = pick(args);\n        context.last_pick_args = args;\n        if (normal) {\n          context[counter].last_pick = picked;\n        }\n        return push_stack(context, 'last_pick', picked);\n      });\n    },\n    pl: function pl(_ref34) {\n      var context = _ref34.context,\n        extra = _ref34.extra,\n        position = _ref34.position;\n      var lastExtra = last(extra);\n      var sig = lastExtra ? last(lastExtra) : '';\n      var counter = 'pl-counter' + position + sig;\n      return expand(function () {\n        if (!context[counter]) context[counter] = 0;\n        context[counter] += 1;\n        var max = arguments.length;\n        var idx = lastExtra && lastExtra[6];\n        if (is_nil(idx)) idx = context[counter];\n        var pos = (idx - 1) % max;\n        var value = pos < 0 || arguments.length <= pos ? undefined : arguments[pos];\n        return push_stack(context, 'last_pick', value);\n      });\n    },\n    pr: function pr(_ref35) {\n      var context = _ref35.context,\n        extra = _ref35.extra,\n        position = _ref35.position;\n      var lastExtra = last(extra);\n      var sig = lastExtra ? last(lastExtra) : '';\n      var counter = 'pr-counter' + position + sig;\n      return expand(function () {\n        if (!context[counter]) context[counter] = 0;\n        context[counter] += 1;\n        var max = arguments.length;\n        var idx = lastExtra && lastExtra[6];\n        if (is_nil(idx)) idx = context[counter];\n        var pos = (idx - 1) % max;\n        var value = max - pos - 1 < 0 || arguments.length <= max - pos - 1 ? undefined : arguments[max - pos - 1];\n        return push_stack(context, 'last_pick', value);\n      });\n    },\n    pd: function pd(_ref36) {\n      var context = _ref36.context,\n        extra = _ref36.extra,\n        position = _ref36.position,\n        shuffle = _ref36.shuffle;\n      var lastExtra = last(extra);\n      var sig = lastExtra ? last(lastExtra) : '';\n      var counter = 'pd-counter' + position + sig;\n      var values = 'pd-values' + position + sig;\n      return expand(function () {\n        if (!context[counter]) context[counter] = 0;\n        context[counter] += 1;\n        for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n          args[_key13] = arguments[_key13];\n        }\n        if (!context[values]) {\n          context[values] = shuffle(args || []);\n        }\n        var max = args.length;\n        var idx = lastExtra && lastExtra[6];\n        if (is_nil(idx)) idx = context[counter];\n        var pos = (idx - 1) % max;\n        var value = context[values][pos];\n        return push_stack(context, 'last_pick', value);\n      });\n    },\n    lp: function lp(_ref37) {\n      var context = _ref37.context;\n      return function () {\n        var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        var stack = context.last_pick;\n        return stack ? stack.last(n) : '';\n      };\n    },\n    r: function r(_ref38) {\n      var context = _ref38.context,\n        rand = _ref38.rand;\n      return function () {\n        for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n          args[_key14] = arguments[_key14];\n        }\n        var transform = args.every(is_letter) ? by_charcode : by_unit;\n        var value = transform(rand).apply(void 0, args);\n        return push_stack(context, 'last_rand', value);\n      };\n    },\n    rn: function rn(_ref39) {\n      var x = _ref39.x,\n        y = _ref39.y,\n        context = _ref39.context,\n        position = _ref39.position,\n        grid = _ref39.grid,\n        extra = _ref39.extra,\n        random = _ref39.random;\n      var counter = 'noise-2d' + position;\n      var counterX = counter + 'offset-x';\n      var counterY = counter + 'offset-y';\n      var _ref40 = last(extra) || [],\n        _ref41 = _slicedToArray(_ref40, 6),\n        ni = _ref41[0],\n        nx = _ref41[1],\n        ny = _ref41[2],\n        nm = _ref41[3],\n        NX = _ref41[4],\n        NY = _ref41[5];\n      var isSeqContext = ni && nm;\n      return function () {\n        for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n          args[_key15] = arguments[_key15];\n        }\n        var _get_named_arguments = get_named_arguments(args, ['from', 'to', 'frequency', 'scale', 'octave']),\n          _get_named_arguments$ = _get_named_arguments.from,\n          from = _get_named_arguments$ === void 0 ? 0 : _get_named_arguments$,\n          _get_named_arguments$2 = _get_named_arguments.to,\n          to = _get_named_arguments$2 === void 0 ? from : _get_named_arguments$2,\n          _get_named_arguments$3 = _get_named_arguments.frequency,\n          frequency = _get_named_arguments$3 === void 0 ? 1 : _get_named_arguments$3,\n          _get_named_arguments$4 = _get_named_arguments.scale,\n          scale = _get_named_arguments$4 === void 0 ? 1 : _get_named_arguments$4,\n          _get_named_arguments$5 = _get_named_arguments.octave,\n          octave = _get_named_arguments$5 === void 0 ? 1 : _get_named_arguments$5;\n        frequency = clamp(frequency, 0, Infinity);\n        scale = clamp(scale, 0, Infinity);\n        octave = clamp(octave, 1, 100);\n        if (args.length == 1) {\n          var _ref42 = [0, from];\n          from = _ref42[0];\n          to = _ref42[1];\n        }\n        if (!context[counter]) context[counter] = new Perlin();\n        if (!context[counterX]) context[counterX] = random();\n        if (!context[counterY]) context[counterY] = random();\n        var transform = is_letter(from) && is_letter(to) ? by_charcode : by_unit;\n        var noise2d = context[counter];\n        var offsetX = context[counterX];\n        var offsetY = context[counterY];\n        var _x = (isSeqContext ? (nx - 1) / NX : (x - 1) / grid.x) + offsetX;\n        var _y = (isSeqContext ? (ny - 1) / NY : (y - 1) / grid.y) + offsetY;\n\n        // 1-dimentional\n        if (NX <= 1 || grid.x <= 1) _x = 0;\n        if (NY <= 1 || grid.y <= 1) _y = 0;\n\n        // 1x1\n        if (_x == 0 && _y == 0) {\n          _x = offsetX;\n          _y = offsetY;\n        }\n        var t = noise2d.noise(_x * frequency, _y * frequency, 0) * scale;\n        for (var i = 1; i < octave; ++i) {\n          var i2 = i * 2;\n          t += noise2d.noise(_x * frequency * i2, _y * frequency * i2, 0) * (scale / i2);\n        }\n        var fn = transform(function (from, to) {\n          return map2d(t, from, to, scale);\n        });\n        return push_stack(context, 'last_rand', fn(from, to));\n      };\n    },\n    lr: function lr(_ref43) {\n      var context = _ref43.context;\n      return function () {\n        var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        var stack = context.last_rand;\n        return stack ? stack.last(n) : '';\n      };\n    },\n    stripe: function stripe() {\n      return function () {\n        for (var _len16 = arguments.length, input = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n          input[_key16] = arguments[_key16];\n        }\n        var colors = input.map(get_value);\n        var max = colors.length;\n        var default_count = 0;\n        var custom_sizes = [];\n        var prev;\n        if (!max) {\n          return '';\n        }\n        colors.forEach(function (step) {\n          var _parse$5 = parse$8(step),\n            _parse$6 = _slicedToArray(_parse$5, 2),\n            _ = _parse$6[0],\n            size = _parse$6[1];\n          if (size !== undefined) custom_sizes.push(size);else default_count += 1;\n        });\n        var default_size = custom_sizes.length ? \"(100% - \".concat(custom_sizes.join(' - '), \") / \").concat(default_count) : \"100% / \".concat(max);\n        return colors.map(function (step, i) {\n          if (custom_sizes.length) {\n            var _parse$7 = parse$8(step),\n              _parse$8 = _slicedToArray(_parse$7, 2),\n              color = _parse$8[0],\n              size = _parse$8[1];\n            var prefix = prev ? prev + ' + ' : '';\n            prev = prefix + (size !== undefined ? size : default_size);\n            return \"\".concat(color, \" 0 calc(\").concat(prev, \")\");\n          }\n          return \"\".concat(step, \" 0 \").concat(100 / max * (i + 1), \"%\");\n        }).join(',');\n      };\n    },\n    calc: function calc() {\n      return function (value) {\n        return calc$1(get_value(value));\n      };\n    },\n    hex: function hex() {\n      return function (value) {\n        return parseInt(get_value(value)).toString(16);\n      };\n    },\n    svg: lazy(function (_) {\n      for (var _len17 = arguments.length, args = new Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {\n        args[_key17 - 1] = arguments[_key17];\n      }\n      var value = args.map(function (input) {\n        return get_value(input());\n      }).join(',');\n      if (!value.startsWith('<')) {\n        var parsed = parse$7(value);\n        value = generate_svg(parsed);\n      }\n      var svg = normalize_svg(value);\n      return create_svg_url(svg);\n    }),\n    Svg: lazy(function (_) {\n      for (var _len18 = arguments.length, args = new Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {\n        args[_key18 - 1] = arguments[_key18];\n      }\n      var value = args.map(function (input) {\n        return get_value(input());\n      }).join(',');\n      if (!value.startsWith('<')) {\n        var parsed = parse$7(value);\n        value = generate_svg(parsed);\n      }\n      return normalize_svg(value);\n    }),\n    filter: lazy(function (upstream) {\n      for (var _len19 = arguments.length, args = new Array(_len19 > 1 ? _len19 - 1 : 0), _key19 = 1; _key19 < _len19; _key19++) {\n        args[_key19 - 1] = arguments[_key19];\n      }\n      var values = args.map(function (input) {\n        return get_value(input());\n      });\n      var value = values.join(',');\n      var id = unique_id('filter-');\n      // shorthand\n      if (values.every(function (n) {\n        return /^[\\d.]/.test(n) || /^(\\w+)/.test(n) && !/[{}<>]/.test(n);\n      })) {\n        var _get_named_arguments2 = get_named_arguments(values, ['frequency', 'scale', 'octave', 'seed', 'blur', 'erode', 'dilate']),\n          frequency = _get_named_arguments2.frequency,\n          _scale5 = _get_named_arguments2.scale,\n          octave = _get_named_arguments2.octave,\n          _get_named_arguments3 = _get_named_arguments2.seed,\n          seed = _get_named_arguments3 === void 0 ? upstream.seed : _get_named_arguments3,\n          blur = _get_named_arguments2.blur,\n          erode = _get_named_arguments2.erode,\n          dilate = _get_named_arguments2.dilate;\n        value = \"\\n        x: -20%;\\n        y: -20%;\\n        width: 140%;\\n        height: 140%;\\n      \";\n        if (!is_nil(dilate)) {\n          value += \"\\n          feMorphology {\\n            operator: dilate;\\n            radius: \".concat(dilate, \";\\n          }\\n        \");\n        }\n        if (!is_nil(erode)) {\n          value += \"\\n          feMorphology {\\n            operator: erode;\\n            radius: \".concat(erode, \";\\n          }\\n        \");\n        }\n        if (!is_nil(blur)) {\n          value += \"\\n          feGaussianBlur {\\n            stdDeviation: \".concat(blur, \";\\n          }\\n        \");\n        }\n        if (!is_nil(frequency)) {\n          var _parse$9 = parse$8(frequency),\n            _parse$10 = _slicedToArray(_parse$9, 2),\n            bx = _parse$10[0],\n            _parse$10$ = _parse$10[1],\n            by = _parse$10$ === void 0 ? bx : _parse$10$;\n          octave = octave ? \"numOctaves: \".concat(octave, \";\") : '';\n          value += \"\\n          feTurbulence {\\n            type: fractalNoise;\\n            baseFrequency: \".concat(bx, \" \").concat(by, \";\\n            seed: \").concat(seed, \";\\n            \").concat(octave, \"\\n          }\\n        \");\n          if (_scale5) {\n            value += \"\\n            feDisplacementMap {\\n              in: SourceGraphic;\\n              scale: \".concat(_scale5, \";\\n            }\\n          \");\n          }\n        }\n      }\n      // new svg syntax\n      if (!value.startsWith('<')) {\n        var parsed = parse$7(value, {\n          type: 'block',\n          name: 'filter'\n        });\n        value = generate_svg(parsed);\n      }\n      var svg = normalize_svg(value).replace(/<filter([\\s>])/, \"<filter id=\\\"\".concat(id, \"\\\"$1\"));\n      return create_svg_url(svg, id);\n    }),\n    'svg-pattern': lazy(function (_) {\n      for (var _len20 = arguments.length, args = new Array(_len20 > 1 ? _len20 - 1 : 0), _key20 = 1; _key20 < _len20; _key20++) {\n        args[_key20 - 1] = arguments[_key20];\n      }\n      var value = args.map(function (input) {\n        return get_value(input());\n      }).join(',');\n      var parsed = parse$7(\"\\n      viewBox: 0 0 1 1;\\n      preserveAspectRatio: xMidYMid slice;\\n      rect {\\n        width, height: 100%;\\n        fill: defs pattern { \".concat(value, \" }\\n      }\\n    \"));\n      var svg = generate_svg(parsed);\n      return create_svg_url(svg);\n    }),\n    var: function _var() {\n      return function (value) {\n        return \"var(\".concat(get_value(value), \")\");\n      };\n    },\n    ut: function ut() {\n      return function (value) {\n        return \"var(--\".concat(uniform_time.name, \")\");\n      };\n    },\n    uw: function uw() {\n      return function (value) {\n        return \"var(--\".concat(uniform_width.name, \")\");\n      };\n    },\n    uh: function uh() {\n      return function (value) {\n        return \"var(--\".concat(uniform_height.name, \")\");\n      };\n    },\n    ux: function ux() {\n      return function (value) {\n        return \"var(--\".concat(uniform_mousex.name, \")\");\n      };\n    },\n    uy: function uy() {\n      return function (value) {\n        return \"var(--\".concat(uniform_mousey.name, \")\");\n      };\n    },\n    plot: function plot(_ref44) {\n      var count = _ref44.count,\n        context = _ref44.context,\n        extra = _ref44.extra,\n        position = _ref44.position,\n        grid = _ref44.grid;\n      var key = 'offset-points' + position;\n      var lastExtra = last(extra);\n      return function (commands) {\n        var _ref45 = lastExtra || [],\n          _ref46 = _slicedToArray(_ref45, 4),\n          _ref46$ = _ref46[0],\n          idx = _ref46$ === void 0 ? count : _ref46$,\n          _ = _ref46[1],\n          __ = _ref46[2],\n          _ref46$2 = _ref46[3],\n          max = _ref46$2 === void 0 ? grid.count : _ref46$2;\n        if (!context[key]) {\n          var config = parse$3(commands);\n          delete config['fill'];\n          delete config['fill-rule'];\n          delete config['frame'];\n          config.points = max;\n          context[key] = create_shape_points(config, {\n            min: 1,\n            max: 65536\n          });\n        }\n        return context[key][idx - 1];\n      };\n    },\n    Plot: function Plot(_ref47) {\n      var count = _ref47.count,\n        context = _ref47.context,\n        extra = _ref47.extra,\n        position = _ref47.position,\n        grid = _ref47.grid;\n      var key = 'Offset-points' + position;\n      var lastExtra = last(extra);\n      return function (commands) {\n        var _ref48 = lastExtra || [],\n          _ref49 = _slicedToArray(_ref48, 4),\n          _ref49$ = _ref49[0],\n          idx = _ref49$ === void 0 ? count : _ref49$,\n          _ = _ref49[1],\n          __ = _ref49[2],\n          _ref49$2 = _ref49[3],\n          max = _ref49$2 === void 0 ? grid.count : _ref49$2;\n        if (!context[key]) {\n          var config = parse$3(commands);\n          delete config['fill'];\n          delete config['fill-rule'];\n          delete config['frame'];\n          config.points = max;\n          config.unit = config.unit || 'none';\n          context[key] = create_shape_points(config, {\n            min: 1,\n            max: 65536\n          });\n        }\n        return context[key][idx - 1];\n      };\n    },\n    shape: function shape() {\n      return memo('shape-function', function () {\n        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        type = String(type).trim();\n        var points = [];\n        if (type.length) {\n          for (var _len21 = arguments.length, args = new Array(_len21 > 1 ? _len21 - 1 : 0), _key21 = 1; _key21 < _len21; _key21++) {\n            args[_key21 - 1] = arguments[_key21];\n          }\n          if (typeof shapes[type] === 'function') {\n            points = shapes[type](args);\n          } else {\n            var _commands = type;\n            var rest = args.join(',');\n            if (rest.length) {\n              _commands = type + ',' + rest;\n            }\n            var config = parse$3(_commands);\n            points = create_shape_points(config, {\n              min: 3,\n              max: 3600\n            });\n          }\n        }\n        return \"polygon(\".concat(points.join(','), \")\");\n      });\n    },\n    doodle: function doodle() {\n      return function (value) {\n        return value;\n      };\n    },\n    shaders: function shaders() {\n      return function (value) {\n        return value;\n      };\n    },\n    canvas: function canvas() {\n      return function (value) {\n        return value;\n      };\n    },\n    pattern: function pattern() {\n      return function (value) {\n        return value;\n      };\n    },\n    invert: function invert() {\n      return function (commands) {\n        var parsed = parse$1(commands);\n        if (!parsed.valid) return commands;\n        return parsed.commands.map(function (_ref50) {\n          var name = _ref50.name,\n            value = _ref50.value;\n          switch (name) {\n            case 'v':\n              return 'h' + value.join(' ');\n            case 'V':\n              return 'H' + value.join(' ');\n            case 'h':\n              return 'v' + value.join(' ');\n            case 'H':\n              return 'V' + value.join(' ');\n            default:\n              return name + value.join(' ');\n          }\n        }).join(' ');\n      };\n    },\n    flipH: function flipH() {\n      return function (commands) {\n        var parsed = parse$1(commands);\n        if (!parsed.valid) return commands;\n        return parsed.commands.map(function (_ref51) {\n          var name = _ref51.name,\n            value = _ref51.value;\n          switch (name) {\n            case 'h':\n            case 'H':\n              return name + value.map(flip_value).join(' ');\n            default:\n              return name + value.join(' ');\n          }\n        }).join(' ');\n      };\n    },\n    flipV: function flipV() {\n      return function (commands) {\n        var parsed = parse$1(commands);\n        if (!parsed.valid) return commands;\n        return parsed.commands.map(function (_ref52) {\n          var name = _ref52.name,\n            value = _ref52.value;\n          switch (name) {\n            case 'v':\n            case 'V':\n              return name + value.map(flip_value).join(' ');\n            default:\n              return name + value.join(' ');\n          }\n        }).join(' ');\n      };\n    },\n    flip: function flip() {\n      var flipH = Expose.flipH.apply(Expose, arguments);\n      var flipV = Expose.flipV.apply(Expose, arguments);\n      return function (commands) {\n        return flipV(flipH(commands));\n      };\n    },\n    reverse: function reverse() {\n      return function () {\n        for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n          args[_key22] = arguments[_key22];\n        }\n        var commands = args.map(get_value);\n        var parsed = parse$1(commands.join(','));\n        if (parsed.valid) {\n          var result = [];\n          for (var i = parsed.commands.length - 1; i >= 0; --i) {\n            var _parsed$commands$i = parsed.commands[i],\n              name = _parsed$commands$i.name,\n              value = _parsed$commands$i.value;\n            result.push(name + value.join(' '));\n          }\n          return result.join(' ');\n        }\n        return commands.reverse();\n      };\n    },\n    cycle: function cycle() {\n      return function () {\n        for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n          args[_key23] = arguments[_key23];\n        }\n        args = args.map(function (n) {\n          return '(' + n + ')';\n        });\n        var list = [];\n        var separator;\n        if (args.length == 1) {\n          separator = ' ';\n          list = parse$8(args[0], {\n            symbol: separator\n          });\n        } else {\n          separator = ',';\n          list = parse$8(args.map(get_value).join(separator), {\n            symbol: separator\n          });\n        }\n        list = list.map(function (n) {\n          return n.replace(/^\\(|\\)$/g, '');\n        });\n        var size = list.length - 1;\n        var result = [list.join(separator)];\n        // Just ignore the performance\n        for (var i = 0; i < size; ++i) {\n          var item = list.shift();\n          list.push(item);\n          result.push(list.join(separator));\n        }\n        return result;\n      };\n    },\n    mirror: function mirror() {\n      return function () {\n        for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n          args[_key24] = arguments[_key24];\n        }\n        for (var i = args.length - 1; i >= 0; --i) {\n          args.push(args[i]);\n        }\n        return args;\n      };\n    },\n    Mirror: function Mirror() {\n      return function () {\n        for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n          args[_key25] = arguments[_key25];\n        }\n        for (var i = args.length - 2; i >= 0; --i) {\n          args.push(args[i]);\n        }\n        return args;\n      };\n    },\n    unicode: function unicode() {\n      return function () {\n        for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n          args[_key26] = arguments[_key26];\n        }\n        return args.map(function (code) {\n          return String.fromCharCode(code);\n        });\n      };\n    },\n    once: function once(_ref53) {\n      var context = _ref53.context,\n        extra = _ref53.extra,\n        position = _ref53.position;\n      var counter = 'once-counter' + position;\n      return function () {\n        if (is_nil(context[counter])) {\n          for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n            args[_key27] = arguments[_key27];\n          }\n          context[counter] = args;\n        }\n        return context[counter];\n      };\n    }\n  }, {\n    'index': 'i',\n    'col': 'x',\n    'row': 'y',\n    'depth': 'z',\n    'rand': 'r',\n    'pick': 'p',\n    'pn': 'pl',\n    'pnr': 'pr',\n    // error prone\n    'stripes': 'stripe',\n    'strip': 'stripe',\n    'patern': 'pattern',\n    'flipv': 'flipV',\n    'fliph': 'flipH',\n    // legacy names, keep them before 1.0\n    't': 'ut',\n    'svg-filter': 'filter',\n    'last-rand': 'lr',\n    'last-pick': 'lp',\n    'multiple': 'm',\n    'multi': 'm',\n    'rep': 'µ',\n    'repeat': 'µ',\n    'ms': 'M',\n    's': 'I',\n    'size': 'I',\n    'sx': 'X',\n    'size-x': 'X',\n    'size-col': 'X',\n    'max-col': 'X',\n    'sy': 'Y',\n    'size-y': 'Y',\n    'size-row': 'Y',\n    'max-row': 'Y',\n    'sz': 'Z',\n    'size-z': 'Z',\n    'size-depth': 'Z',\n    'pick-by-turn': 'pl',\n    'pick-n': 'pl',\n    'pick-d': 'pd',\n    'offset': 'plot',\n    'Offset': 'Plot',\n    'point': 'plot',\n    'Point': 'Plot',\n    'paint': 'canvas'\n  });\n  var presets = {\n    '4a0': [1682, 2378],\n    '2a0': [1189, 1682],\n    a0: [841, 1189],\n    a1: [594, 841],\n    a2: [420, 594],\n    a3: [297, 420],\n    a4: [210, 297],\n    a5: [148, 210],\n    a6: [105, 148],\n    a7: [74, 105],\n    a8: [52, 74],\n    a9: [37, 52],\n    a10: [26, 37],\n    b0: [1000, 1414],\n    b1: [707, 1000],\n    b2: [500, 707],\n    b3: [353, 500],\n    b4: [250, 353],\n    b5: [176, 250],\n    b6: [125, 176],\n    b7: [88, 125],\n    b8: [62, 88],\n    b9: [44, 62],\n    b10: [31, 44],\n    b11: [22, 32],\n    b12: [16, 22],\n    c0: [917, 1297],\n    c1: [648, 917],\n    c2: [458, 648],\n    c3: [324, 458],\n    c4: [229, 324],\n    c5: [162, 229],\n    c6: [114, 162],\n    c7: [81, 114],\n    c8: [57, 81],\n    c9: [40, 57],\n    c10: [28, 40],\n    c11: [22, 32],\n    c12: [16, 22],\n    d0: [764, 1064],\n    d1: [532, 760],\n    d2: [380, 528],\n    d3: [264, 376],\n    d4: [188, 260],\n    d5: [130, 184],\n    d6: [92, 126],\n    letter: [216, 279],\n    postcard: [100, 148],\n    poster: [390, 540]\n  };\n  var modes = {\n    portrait: 'p',\n    pt: 'p',\n    p: 'p',\n    landscape: 'l',\n    ls: 'l',\n    l: 'l'\n  };\n  var unit = 'mm';\n  function get_preset(name, mode) {\n    name = String(name).toLowerCase();\n\n    // Default to landscape mode\n    var _ref54 = presets[name] || [],\n      _ref55 = _slicedToArray(_ref54, 2),\n      h = _ref55[0],\n      w = _ref55[1];\n    if (modes[mode] == 'p') {\n      var _ref56 = [h, w];\n      w = _ref56[0];\n      h = _ref56[1];\n    }\n    return [w, h].map(function (n) {\n      return n + unit;\n    });\n  }\n  function is_preset(name) {\n    return !!presets[name];\n  }\n  var all_props = [];\n  function get_props(arg) {\n    if (!all_props.length) {\n      var props = new Set();\n      if (typeof document !== 'undefined') {\n        for (var n in document.head.style) {\n          if (!n.startsWith('-')) {\n            props.add(n.replace(/[A-Z]/g, '-$&').toLowerCase());\n          }\n        }\n      }\n      if (!props.has('grid-gap')) {\n        props.add('grid-gap');\n      }\n      all_props = Array.from(props);\n    }\n    return arg instanceof RegExp ? all_props.filter(function (n) {\n      return arg.test(n);\n    }) : all_props;\n  }\n  function build_mapping(prefix) {\n    var reg = new RegExp(\"\\\\-?\".concat(prefix, \"\\\\-?\"));\n    return get_props(reg).map(function (n) {\n      return n.replace(reg, '');\n    }).reduce(function (obj, n) {\n      return obj[n] = n, obj;\n    }, {});\n  }\n  var props_webkit_mapping = build_mapping('webkit');\n  var props_moz_mapping = build_mapping('moz');\n  function prefixer(prop, rule) {\n    if (props_webkit_mapping[prop]) {\n      return \"-webkit-\".concat(rule, \" \").concat(rule);\n    } else if (props_moz_mapping[prop]) {\n      return \"-moz-\".concat(rule, \" \").concat(rule);\n    }\n    return rule;\n  }\n  var map_left_right = {\n    center: '50%',\n    left: '0%',\n    right: '100%',\n    top: '50%',\n    bottom: '50%'\n  };\n  var map_top_bottom = {\n    center: '50%',\n    top: '0%',\n    bottom: '100%',\n    left: '50%',\n    right: '50%'\n  };\n  var Property = add_alias({\n    size: function size(value, _ref57) {\n      var is_special_selector = _ref57.is_special_selector,\n        grid = _ref57.grid;\n      var _parse$11 = parse$8(value),\n        _parse$12 = _slicedToArray(_parse$11, 3),\n        w = _parse$12[0],\n        _parse$12$ = _parse$12[1],\n        h = _parse$12$ === void 0 ? w : _parse$12$,\n        ratio = _parse$12[2];\n      if (is_preset(w)) {\n        var _get_preset = get_preset(w, h);\n        var _get_preset2 = _slicedToArray(_get_preset, 2);\n        w = _get_preset2[0];\n        h = _get_preset2[1];\n      }\n      var styles = \"\\n      width: \".concat(w, \";\\n      height: \").concat(h, \";\\n    \");\n      if (w === 'auto' || h === 'auto') {\n        if (ratio) {\n          if (/^\\(.+\\)$/.test(ratio)) {\n            ratio = ratio.substring(1, ratio.length - 1);\n          } else if (!/^calc/.test(ratio)) {\n            ratio = \"calc(\".concat(ratio, \")\");\n          }\n          if (!is_special_selector) {\n            styles += \"aspect-ratio: \".concat(ratio, \";\");\n          }\n        }\n        if (is_special_selector) {\n          styles += \"aspect-ratio: \".concat(ratio || grid.ratio, \";\");\n        }\n      }\n      if (!is_special_selector) {\n        styles += \"\\n        --internal-cell-width: \".concat(w, \";\\n        --internal-cell-height: \").concat(h, \";\\n      \");\n      }\n      return styles;\n    },\n    place: function place(value, _ref58) {\n      var extra = _ref58.extra;\n      var _parse$13 = parse$8(value),\n        _parse$14 = _slicedToArray(_parse$13, 2),\n        left = _parse$14[0],\n        _parse$14$ = _parse$14[1],\n        top = _parse$14$ === void 0 ? '50%' : _parse$14$;\n      left = map_left_right[left] || left;\n      top = map_top_bottom[top] || top;\n      var cw = 'var(--internal-cell-width, 25%)';\n      var ch = 'var(--internal-cell-height, 25%)';\n      return \"\\n      position: absolute;\\n      left: \".concat(left, \";\\n      top: \").concat(top, \";\\n      width: \").concat(cw, \";\\n      height: \").concat(ch, \";\\n      margin-left: calc(\").concat(cw, \" / -2);\\n      margin-top: calc(\").concat(ch, \" / -2);\\n      grid-area: unset;\\n      --plot-angle: \").concat(extra || 0, \";\\n      rotate: \").concat(extra || 0, \"deg;\\n    \");\n    },\n    grid: function grid(value, options) {\n      var result = {\n        clip: true\n      };\n      if (/no\\-*clip/i.test(value)) {\n        result.clip = false;\n        value = value.replace(/no\\-*clip/i, '');\n      }\n      var groups = parse$8(value, {\n        symbol: ['/', '+', '*', '|', '-', '~'],\n        noSpace: true,\n        verbose: true\n      });\n      var _iterator6 = _createForOfIteratorHelper(groups),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _step6$value = _step6.value,\n            group = _step6$value.group,\n            _value2 = _step6$value.value;\n          if (group === '+') result.scale = _value2;\n          if (group === '*') result.rotate = _value2;\n          if (group === '~') result.translate = _value2;\n          if (group === '/') {\n            if (result.size === undefined) result.size = this.size(_value2, options);else result.fill = _value2;\n          }\n          if ((group === '|' || group == '-' || group == '') && !result.grid) {\n            result.grid = parse_grid(_value2, options.max_grid);\n            if (group === '|') {\n              result.flexColumn = true;\n            }\n            if (group === '-') {\n              result.flexRow = true;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return result;\n    },\n    gap: function gap(value) {\n      return value;\n    },\n    seed: function seed(value) {\n      return value;\n    },\n    shape: memo('shape-property', function (value) {\n      var _parse$15 = parse$8(value),\n        _parse$16 = _toArray(_parse$15),\n        type = _parse$16[0],\n        args = _parse$16.slice(1);\n      if (typeof shapes[type] !== 'function') return '';\n      var prop = 'clip-path';\n      var points = shapes[type].apply(shapes, _toConsumableArray(args));\n      var rules = \"\".concat(prop, \": polygon(\").concat(points.join(','), \");\");\n      return prefixer(prop, rules) + 'overflow: hidden;';\n    }),\n    use: function use(rules) {\n      if (rules.length > 2) {\n        return rules;\n      }\n    },\n    content: function content(value) {\n      return value;\n    }\n  }, {\n    // legacy names.\n    'place-cell': 'place',\n    'offset': 'place',\n    'position': 'place'\n  });\n  var literal = {\n    even: function even(n) {\n      return !(n % 2);\n    },\n    odd: function odd(n) {\n      return !!(n % 2);\n    }\n  };\n\n  /**\n   * TODO: optimization\n   */\n  function _nth(input, curr, max) {\n    for (var i = 0; i <= max; ++i) {\n      if (calc$1(input, {\n        n: i\n      }) == curr) {\n        return true;\n      }\n    }\n  }\n  var Selector = {\n    at: function at(_ref59) {\n      var x = _ref59.x,\n        y = _ref59.y;\n      return function (x1, y1) {\n        return x == x1 && y == y1;\n      };\n    },\n    nth: function nth(_ref60) {\n      var count = _ref60.count,\n        grid = _ref60.grid;\n      return function () {\n        for (var _len28 = arguments.length, exprs = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {\n          exprs[_key28] = arguments[_key28];\n        }\n        return exprs.some(function (expr) {\n          return literal[expr] ? literal[expr](count) : _nth(expr, count, grid.count);\n        });\n      };\n    },\n    row: function row(_ref61) {\n      var y = _ref61.y,\n        grid = _ref61.grid;\n      return function () {\n        for (var _len29 = arguments.length, exprs = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {\n          exprs[_key29] = arguments[_key29];\n        }\n        return exprs.some(function (expr) {\n          return literal[expr] ? literal[expr](y) : _nth(expr, y, grid.y);\n        });\n      };\n    },\n    col: function col(_ref62) {\n      var x = _ref62.x,\n        grid = _ref62.grid;\n      return function () {\n        for (var _len30 = arguments.length, exprs = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {\n          exprs[_key30] = arguments[_key30];\n        }\n        return exprs.some(function (expr) {\n          return literal[expr] ? literal[expr](x) : _nth(expr, x, grid.x);\n        });\n      };\n    },\n    even: function even(_ref63) {\n      var count = _ref63.count,\n        grid = _ref63.grid,\n        x = _ref63.x,\n        y = _ref63.y;\n      return function (arg) {\n        return literal.odd(x + y);\n      };\n    },\n    odd: function odd(_ref64) {\n      var count = _ref64.count,\n        grid = _ref64.grid,\n        x = _ref64.x,\n        y = _ref64.y;\n      return function (arg) {\n        return literal.even(x + y);\n      };\n    },\n    random: function random(_ref65) {\n      var _random = _ref65.random,\n        count = _ref65.count,\n        x = _ref65.x,\n        y = _ref65.y,\n        grid = _ref65.grid;\n      return function () {\n        var ratio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .5;\n        if (/\\D/.test(ratio)) {\n          return _random() < calc$1('(' + ratio + ')', {\n            x: x,\n            X: grid.x,\n            y: y,\n            Y: grid.y,\n            i: count,\n            I: grid.count,\n            random: _random\n          });\n        }\n        return _random() < ratio;\n      };\n    },\n    match: function match(_ref66) {\n      var count = _ref66.count,\n        grid = _ref66.grid,\n        x = _ref66.x,\n        y = _ref66.y,\n        random = _ref66.random;\n      return function (expr) {\n        return !!calc$1('(' + expr + ')', {\n          x: x,\n          X: grid.x,\n          y: y,\n          Y: grid.y,\n          i: count,\n          I: grid.count,\n          random: random\n        });\n      };\n    }\n  };\n\n  /*\n  Copyright 2019 David Bau.\n  Permission is hereby granted, free of charge, to any person obtaining\n  a copy of this software and associated documentation files (the\n  \"Software\"), to deal in the Software without restriction, including\n  without limitation the rights to use, copy, modify, merge, publish,\n  distribute, sublicense, and/or sell copies of the Software, and to\n  permit persons to whom the Software is furnished to do so, subject to\n  the following conditions:\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n  */\n\n  var global = globalThis;\n  var math = Math;\n  var pool = [];\n\n  //\n  // The following constants are related to IEEE 754 limits.\n  //\n\n  var width = 256,\n    // each RC4 output is 0 <= x < 256\n    chunks = 6,\n    // at least six RC4 outputs for each double\n    digits = 52,\n    // there are 52 significant digits in a double\n    rngname = 'random',\n    // rngname: name for Math.random and Math.seedrandom\n    startdenom = math.pow(width, chunks),\n    significance = math.pow(2, digits),\n    overflow = significance * 2,\n    mask = width - 1,\n    nodecrypto; // node.js crypto module, initialized at the bottom.\n\n  //\n  // seedrandom()\n  // This is the seedrandom function described above.\n  //\n  function seedrandom(seed, options, callback) {\n    var key = [];\n    options = options == true ? {\n      entropy: true\n    } : options || {};\n\n    // Flatten the seed string or build one from local entropy if needed.\n    var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed, 3), key);\n\n    // Use the seed to initialize an ARC4 generator.\n    var arc4 = new ARC4(key);\n\n    // This function returns a random double in [0, 1) that contains\n    // randomness in every bit of the mantissa of the IEEE 754 value.\n    var prng = function prng() {\n      var n = arc4.g(chunks),\n        // Start with a numerator n < 2 ^ 48\n        d = startdenom,\n        //   and denominator d = 2 ^ 48.\n        x = 0; //   and no 'extra last byte'.\n      while (n < significance) {\n        // Fill up all significant digits by\n        n = (n + x) * width; //   shifting numerator and\n        d *= width; //   denominator and generating a\n        x = arc4.g(1); //   new least-significant-byte.\n      }\n\n      while (n >= overflow) {\n        // To avoid rounding up, before adding\n        n /= 2; //   last byte, shift everything\n        d /= 2; //   right using integer math until\n        x >>>= 1; //   we have exactly the desired bits.\n      }\n\n      return (n + x) / d; // Form the number within [0, 1).\n    };\n\n    prng.int32 = function () {\n      return arc4.g(4) | 0;\n    };\n    prng.quick = function () {\n      return arc4.g(4) / 0x100000000;\n    };\n    prng.double = prng;\n\n    // Mix the randomness into accumulated entropy.\n    mixkey(tostring(arc4.S), pool);\n\n    // Calling convention: what to return as a function of prng, seed, is_math.\n    return (options.pass || callback || function (prng, seed, is_math_call, state) {\n      if (state) {\n        // Load the arc4 state from the given state if it has an S array.\n        if (state.S) {\n          copy(state, arc4);\n        }\n        // Only provide the .state method if requested via options.state.\n        prng.state = function () {\n          return copy(arc4, {});\n        };\n      }\n\n      // If called as a method of Math (Math.seedrandom()), mutate\n      // Math.random because that is how seedrandom.js has worked since v1.0.\n      if (is_math_call) {\n        math[rngname] = prng;\n        return seed;\n      }\n\n      // Otherwise, it is a newer calling convention, so return the\n      // prng directly.\n      else return prng;\n    })(prng, shortseed, 'global' in options ? options.global : this == math, options.state);\n  }\n\n  //\n  // ARC4\n  //\n  // An ARC4 implementation.  The constructor takes a key in the form of\n  // an array of at most (width) integers that should be 0 <= x < (width).\n  //\n  // The g(count) method returns a pseudorandom integer that concatenates\n  // the next (count) outputs from ARC4.  Its return value is a number x\n  // that is in the range 0 <= x < (width ^ count).\n  //\n  function ARC4(key) {\n    var t,\n      keylen = key.length,\n      me = this,\n      i = 0,\n      j = me.i = me.j = 0,\n      s = me.S = [];\n\n    // The empty key [] is treated as [0].\n    if (!keylen) {\n      key = [keylen++];\n    }\n\n    // Set up S using the standard key scheduling algorithm.\n    while (i < width) {\n      s[i] = i++;\n    }\n    for (i = 0; i < width; i++) {\n      s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];\n      s[j] = t;\n    }\n\n    // The \"g\" method returns the next (count) outputs as one number.\n    (me.g = function (count) {\n      // Using instance members instead of closure state nearly doubles speed.\n      var t,\n        r = 0,\n        i = me.i,\n        j = me.j,\n        s = me.S;\n      while (count--) {\n        t = s[i = mask & i + 1];\n        r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];\n      }\n      me.i = i;\n      me.j = j;\n      return r;\n      // For robust unpredictability, the function call below automatically\n      // discards an initial batch of values.  This is called RC4-drop[256].\n      // See http://google.com/search?q=rsa+fluhrer+response&btnI\n    })(width);\n  }\n\n  //\n  // copy()\n  // Copies internal state of ARC4 to or from a plain object.\n  //\n  function copy(f, t) {\n    t.i = f.i;\n    t.j = f.j;\n    t.S = f.S.slice();\n    return t;\n  }\n  //\n  // flatten()\n  // Converts an object tree to nested arrays of strings.\n  //\n  function flatten(obj, depth) {\n    var result = [],\n      typ = typeof obj,\n      prop;\n    if (depth && typ == 'object') {\n      for (prop in obj) {\n        try {\n          result.push(flatten(obj[prop], depth - 1));\n        } catch (e) {}\n      }\n    }\n    return result.length ? result : typ == 'string' ? obj : obj + '\\0';\n  }\n\n  //\n  // mixkey()\n  // Mixes a string seed into a key that is an array of integers, and\n  // returns a shortened string seed that is equivalent to the result key.\n  //\n  function mixkey(seed, key) {\n    var stringseed = seed + '',\n      smear,\n      j = 0;\n    while (j < stringseed.length) {\n      key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);\n    }\n    return tostring(key);\n  }\n\n  //\n  // autoseed()\n  // Returns an object for autoseeding, using window.crypto and Node crypto\n  // module if available.\n  //\n  function autoseed() {\n    try {\n      var out;\n      if (nodecrypto && (out = nodecrypto.randomBytes)) ;else {\n        out = new Uint8Array(width);\n        (global.crypto || global.msCrypto).getRandomValues(out);\n      }\n      return tostring(out);\n    } catch (e) {\n      var browser = global.navigator,\n        plugins = browser && browser.plugins;\n      return [+new Date(), global, plugins, global.screen, tostring(pool)];\n    }\n  }\n\n  //\n  // tostring()\n  // Converts an array of charcodes to a string\n  //\n  function tostring(a) {\n    return String.fromCharCode.apply(0, a);\n  }\n\n  //\n  // When seedrandom.js is loaded, we immediately mix a few bits\n  // from the built-in RNG into the entropy pool.  Because we do\n  // not want to interfere with deterministic PRNG state later,\n  // seedrandom will not call math.random on its own again after\n  // initialization.\n  //\n  mixkey(math.random(), pool);\n  function is_host_selector(s) {\n    return /^\\:(host|doodle)/.test(s);\n  }\n  function is_parent_selector(s) {\n    return /^\\:(container|parent)/.test(s);\n  }\n  function is_special_selector(s) {\n    return is_host_selector(s) || is_parent_selector(s);\n  }\n  function is_pseudo_selecotr(s) {\n    return /\\:before|\\:after/.test(s);\n  }\n  var MathFunc = {};\n  var _iterator7 = _createForOfIteratorHelper(Object.getOwnPropertyNames(Math)),\n    _step7;\n  try {\n    var _loop3 = function _loop3() {\n      var name = _step7.value;\n      MathFunc[name] = function () {\n        return function () {\n          for (var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {\n            args[_key35] = arguments[_key35];\n          }\n          if (typeof Math[name] === 'number') {\n            return Math[name];\n          }\n          args = args.map(function (n) {\n            return calc$1(get_value(n));\n          });\n          return Math[name].apply(Math, _toConsumableArray(args));\n        };\n      };\n    };\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      _loop3();\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  var Rules = /*#__PURE__*/function () {\n    function Rules(tokens) {\n      _classCallCheck(this, Rules);\n      this.tokens = tokens;\n      this.rules = {};\n      this.props = {};\n      this.keyframes = {};\n      this.grid = null;\n      this.seed = null;\n      this.is_grid_defined = false;\n      this.is_gap_defined = false;\n      this.coords = [];\n      this.doodles = {};\n      this.canvas = {};\n      this.pattern = {};\n      this.shaders = {};\n      this.reset();\n      this.custom_properties = {};\n      this.uniforms = {};\n      this.content = {};\n    }\n    _createClass(Rules, [{\n      key: \"reset\",\n      value: function reset() {\n        this.styles = {\n          host: '',\n          container: '',\n          cells: '',\n          keyframes: ''\n        };\n        this.coords = [];\n        this.doodles = {};\n        this.canvas = {};\n        this.pattern = {};\n        this.shaders = {};\n        this.content = {};\n        for (var key in this.rules) {\n          if (key.startsWith('#c')) {\n            delete this.rules[key];\n          }\n        }\n      }\n    }, {\n      key: \"add_rule\",\n      value: function add_rule(selector, rule) {\n        var rules = this.rules[selector];\n        if (!rules) {\n          rules = this.rules[selector] = [];\n        }\n        rules.push.apply(rules, make_array(rule));\n      }\n    }, {\n      key: \"pick_func\",\n      value: function pick_func(name) {\n        return Expose[name] || MathFunc[name];\n      }\n    }, {\n      key: \"apply_func\",\n      value: function apply_func(fn, coords, args) {\n        var _fn = fn.apply(void 0, _toConsumableArray(make_array(coords)));\n        var input = [];\n        args.forEach(function (arg) {\n          var type = typeof arg.value;\n          var is_string_or_number = type === 'number' || type === 'string';\n          if (!arg.cluster && is_string_or_number) {\n            var _input;\n            (_input = input).push.apply(_input, _toConsumableArray(parse$8(arg.value, {\n              noSpace: true\n            })));\n          } else {\n            if (typeof arg === 'function') {\n              input.push(arg);\n            } else if (!is_nil(arg.value)) {\n              var value = get_value(arg.value);\n              input.push(value);\n            }\n          }\n        });\n        input = remove_empty_values(input);\n        var result = _fn.apply(void 0, _toConsumableArray(make_array(input)));\n        return result;\n      }\n    }, {\n      key: \"compose_aname\",\n      value: function compose_aname() {\n        for (var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {\n          args[_key31] = arguments[_key31];\n        }\n        return args.join('-');\n      }\n    }, {\n      key: \"compose_selector\",\n      value: function compose_selector(_ref67) {\n        var x = _ref67.x,\n          y = _ref67.y,\n          z = _ref67.z;\n        var pseudo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        return \"#\".concat(cell_id(x, y, z)).concat(pseudo);\n      }\n    }, {\n      key: \"is_composable\",\n      value: function is_composable(name) {\n        return ['doodle', 'shaders', 'canvas', 'pattern'].includes(name);\n      }\n    }, {\n      key: \"read_var\",\n      value: function read_var(value, coords) {\n        var count = coords.count;\n        var group = Object.assign({}, this.custom_properties['host'], this.custom_properties['container'], this.custom_properties[count]);\n        if (group[value] !== undefined) {\n          var result = String(group[value]).trim();\n          if (result[0] == '(') {\n            var _last2 = result[result.length - 1];\n            if (_last2 === ')') {\n              result = result.substring(1, result.length - 1);\n            }\n          }\n          return result.replace(/;+$/g, '');\n        }\n        return value;\n      }\n    }, {\n      key: \"compose_argument\",\n      value: function compose_argument(argument, coords) {\n        var _this2 = this;\n        var extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        var parent = arguments.length > 3 ? arguments[3] : undefined;\n        if (!coords.extra) coords.extra = [];\n        coords.extra.push(extra);\n        var result = argument.map(function (arg) {\n          if (arg.type === 'text') {\n            if (/^\\-\\-\\w/.test(arg.value)) {\n              if (parent && parent.name === '@var') {\n                return arg.value;\n              }\n              return _this2.read_var(arg.value, coords);\n            }\n            return arg.value;\n          } else if (arg.type === 'func') {\n            var fname = arg.name.substr(1);\n            var fn = _this2.pick_func(fname);\n            if (typeof fn === 'function') {\n              _this2.check_uniforms(fname);\n              if (_this2.is_composable(fname)) {\n                var _value3 = get_value((arg.arguments[0] || [])[0]);\n                var temp_arg;\n                if (fname === 'doodle') {\n                  if (/^\\d/.test(_value3)) {\n                    temp_arg = _value3;\n                    _value3 = get_value((val.arguments[1] || [])[0]);\n                  }\n                }\n                if (!is_nil(_value3)) {\n                  switch (fname) {\n                    case 'doodle':\n                      return _this2.compose_doodle(_this2.inject_variables(_value3, coords.count), temp_arg);\n                    case 'shaders':\n                      return _this2.compose_shaders(_value3, coords);\n                    case 'canvas':\n                      return _this2.compose_canvas(_value3, arg.arguments.slice(1));\n                    case 'pattern':\n                      return _this2.compose_pattern(_value3, coords);\n                  }\n                }\n              }\n              coords.position = arg.position;\n              var args = arg.arguments.map(function (n) {\n                return fn.lazy ? function () {\n                  for (var _len32 = arguments.length, extra = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {\n                    extra[_key32] = arguments[_key32];\n                  }\n                  return _this2.compose_argument(n, coords, extra, arg);\n                } : _this2.compose_argument(n, coords, extra, arg);\n              });\n              var value = _this2.apply_func(fn, coords, args);\n              return value;\n            } else {\n              return arg.name;\n            }\n          }\n        });\n        coords.extra.pop();\n        return {\n          cluster: argument.cluster,\n          value: result.length >= 2 ? {\n            value: result.join('')\n          } : result[0]\n        };\n      }\n    }, {\n      key: \"compose_doodle\",\n      value: function compose_doodle(doodle, arg) {\n        var id = unique_id('doodle');\n        this.doodles[id] = {\n          doodle: doodle,\n          arg: arg\n        };\n        return '${' + id + '}';\n      }\n    }, {\n      key: \"compose_shaders\",\n      value: function compose_shaders(shader, _ref68) {\n        var x = _ref68.x,\n          y = _ref68.y,\n          z = _ref68.z;\n        var id = unique_id('shader');\n        this.shaders[id] = {\n          id: '--' + id,\n          shader: shader,\n          cell: cell_id(x, y, z)\n        };\n        return '${' + id + '}';\n      }\n    }, {\n      key: \"compose_pattern\",\n      value: function compose_pattern(code, _ref69) {\n        var x = _ref69.x,\n          y = _ref69.y,\n          z = _ref69.z;\n        var id = unique_id('pattern');\n        this.pattern[id] = {\n          id: '--' + id,\n          code: code,\n          cell: cell_id(x, y, z)\n        };\n        return '${' + id + '}';\n      }\n    }, {\n      key: \"compose_canvas\",\n      value: function compose_canvas(code) {\n        var rest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        var commands = code;\n        var result = rest.map(function (group) {\n          return get_value(group[0]);\n        }).join(',');\n        if (result.length) {\n          commands = code + ',' + result;\n        }\n        var id = unique_id('canvas');\n        this.canvas[id] = {\n          code: commands\n        };\n        return '${' + id + '}';\n      }\n    }, {\n      key: \"check_uniforms\",\n      value: function check_uniforms(name) {\n        switch (name) {\n          case 'ut':\n          case 't':\n            this.uniforms.time = true;\n            break;\n          case 'ux':\n            this.uniforms.mousex = true;\n            break;\n          case 'uy':\n            this.uniforms.mousey = true;\n            break;\n          case 'uw':\n            this.uniforms.width = true;\n            break;\n          case 'uh':\n            this.uniforms.height = true;\n            break;\n        }\n      }\n    }, {\n      key: \"inject_variables\",\n      value: function inject_variables(value, count) {\n        var group = Object.assign({}, this.custom_properties['host'], this.custom_properties['container'], this.custom_properties[count]);\n        var variables = [];\n        for (var _i9 = 0, _Object$entries4 = Object.entries(group); _i9 < _Object$entries4.length; _i9++) {\n          var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i9], 2),\n            name = _Object$entries4$_i[0],\n            key = _Object$entries4$_i[1];\n          variables.push(\"\".concat(name, \": \").concat(key, \";\"));\n        }\n        variables = variables.join('');\n        if (variables.length) {\n          return \":doodle { \".concat(variables, \" }\") + value;\n        }\n        return value;\n      }\n    }, {\n      key: \"compose_value\",\n      value: function compose_value(value, coords) {\n        var _this3 = this;\n        if (!Array.isArray(value)) {\n          return {\n            value: '',\n            extra: ''\n          };\n        }\n        var extra = '';\n        var output = value.reduce(function (result, val) {\n          switch (val.type) {\n            case 'text':\n              {\n                result += val.value;\n                break;\n              }\n            case 'func':\n              {\n                var fname = val.name.substr(1);\n                var fn = _this3.pick_func(fname);\n                if (typeof fn === 'function') {\n                  _this3.check_uniforms(fname);\n                  if (_this3.is_composable(fname)) {\n                    var _value4 = get_value((val.arguments[0] || [])[0]);\n                    var temp_arg;\n                    if (fname === 'doodle') {\n                      if (/^\\d/.test(_value4)) {\n                        temp_arg = _value4;\n                        _value4 = get_value((val.arguments[1] || [])[0]);\n                      }\n                    }\n                    if (!is_nil(_value4)) {\n                      switch (fname) {\n                        case 'doodle':\n                          result += _this3.compose_doodle(_this3.inject_variables(_value4, coords.count), temp_arg);\n                          break;\n                        case 'shaders':\n                          result += _this3.compose_shaders(_value4, coords);\n                          break;\n                        case 'pattern':\n                          result += _this3.compose_pattern(_value4, coords);\n                          break;\n                        case 'canvas':\n                          result += _this3.compose_canvas(_value4, val.arguments.slice(1));\n                          break;\n                      }\n                    }\n                  } else {\n                    coords.position = val.position;\n                    var args = val.arguments.map(function (arg) {\n                      return fn.lazy ? function () {\n                        for (var _len33 = arguments.length, extra = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {\n                          extra[_key33] = arguments[_key33];\n                        }\n                        return _this3.compose_argument(arg, coords, extra, val);\n                      } : _this3.compose_argument(arg, coords, [], val);\n                    });\n                    var _output = _this3.apply_func(fn, coords, args);\n                    if (!is_nil(_output)) {\n                      result += _output;\n                      if (_output.extra) {\n                        extra = _output.extra;\n                      }\n                    }\n                  }\n                } else {\n                  result += val.name;\n                }\n              }\n          }\n          return result;\n        }, '');\n        return {\n          value: output,\n          extra: extra\n        };\n      }\n    }, {\n      key: \"add_grid_style\",\n      value: function add_grid_style(_ref70) {\n        var fill = _ref70.fill,\n          clip = _ref70.clip,\n          rotate = _ref70.rotate,\n          scale = _ref70.scale,\n          translate = _ref70.translate,\n          flexRow = _ref70.flexRow,\n          flexColumn = _ref70.flexColumn;\n        if (fill) {\n          this.add_rule(':host', \"background-color: \".concat(fill, \";\"));\n        }\n        if (!clip) {\n          this.add_rule(':host', 'contain: none;');\n        }\n        if (rotate) {\n          this.add_rule(':container', \"rotate: \".concat(rotate, \";\"));\n        }\n        if (scale) {\n          this.add_rule(':container', \"scale: \".concat(scale, \";\"));\n        }\n        if (translate) {\n          this.add_rule(':container', \"translate: \".concat(translate, \";\"));\n        }\n        if (flexRow) {\n          this.add_rule(':container', \"display: flex\");\n          this.add_rule('cell', \"flex: 1\");\n        }\n        if (flexColumn) {\n          this.add_rule(':container', \"display: flex; flex-direction: column;\");\n          this.add_rule('cell', \"flex: 1\");\n        }\n      }\n    }, {\n      key: \"compose_rule\",\n      value: function compose_rule(token, _coords, selector) {\n        var _this4 = this;\n        var coords = Object.assign({}, _coords);\n        var prop = token.property;\n        var extra;\n        if (prop === '@seed') {\n          return '';\n        }\n        var value_group = token.value.reduce(function (ret, v) {\n          var composed = _this4.compose_value(v, coords);\n          if (composed) {\n            if (composed.value) {\n              ret.push(composed.value);\n            }\n            if (composed.extra) {\n              extra = composed.extra;\n            }\n          }\n          return ret;\n        }, []);\n        var value = value_group.join(', ');\n        if (/^animation(\\-name)?$/.test(prop)) {\n          this.props.has_animation = true;\n          if (is_host_selector(selector)) {\n            var prefix = uniform_time[prop];\n            if (prefix && value) {\n              value = prefix + ',' + value;\n            }\n          }\n          if (coords.count > 1) {\n            var count = coords.count;\n            switch (prop) {\n              case 'animation-name':\n                {\n                  value = value_group.map(function (n) {\n                    return _this4.compose_aname(n, count);\n                  }).join(', ');\n                  break;\n                }\n              case 'animation':\n                {\n                  value = value_group.map(function (n) {\n                    var group = (n || '').split(/\\s+/);\n                    group[0] = _this4.compose_aname(group[0], count);\n                    return group.join(' ');\n                  }).join(', ');\n                }\n            }\n          }\n        }\n        if (prop === 'content') {\n          if (!/[\"']|^none\\s?$|^(var|counter|counters|attr|url)\\(/.test(value)) {\n            value = \"'\".concat(value, \"'\");\n          }\n        }\n        if (prop === 'transition') {\n          this.props.has_transition = true;\n        }\n        var rule = \"\".concat(prop, \": \").concat(value, \";\");\n        rule = prefixer(prop, rule);\n        if (prop === 'clip-path') {\n          // fix clip bug\n          rule += ';overflow: hidden;';\n        }\n        if (prop === 'width' || prop === 'height') {\n          if (!is_special_selector(selector)) {\n            rule += \"--internal-cell-\".concat(prop, \": \").concat(value, \";\");\n          }\n        }\n        var is_image = /^(background|background\\-image)$/.test(prop) && /\\$\\{(canvas|shader|pattern)/.test(value);\n        if (is_image) {\n          rule += 'background-size: 100% 100%;';\n        }\n        if (/^\\-\\-/.test(prop)) {\n          var key = _coords.count;\n          if (is_parent_selector(selector)) {\n            key = 'container';\n          }\n          if (is_host_selector(selector)) {\n            key = 'host';\n          }\n          if (!this.custom_properties[key]) {\n            this.custom_properties[key] = {};\n          }\n          this.custom_properties[key][prop] = value;\n        }\n        if (/^@/.test(prop) && Property[prop.substr(1)]) {\n          var name = prop.substr(1);\n          var transformed = Property[name](value, {\n            is_special_selector: is_special_selector(selector),\n            grid: coords.grid,\n            max_grid: coords.max_grid,\n            extra: extra\n          });\n          switch (name) {\n            case 'grid':\n              {\n                if (is_host_selector(selector)) {\n                  rule = transformed.size || '';\n                  this.add_grid_style(transformed);\n                } else {\n                  rule = '';\n                  if (!this.is_grid_defined) {\n                    transformed = Property[name](value, {\n                      is_special_selector: true,\n                      grid: coords.grid,\n                      max_grid: coords.max_grid\n                    });\n                    this.add_rule(':host', transformed.size || '');\n                    this.add_grid_style(transformed);\n                  }\n                }\n                this.grid = coords.grid;\n                this.is_grid_defined = true;\n                break;\n              }\n            case 'gap':\n              {\n                rule = '';\n                if (!this.is_gap_defined) {\n                  this.add_rule(':container', \"gap: \".concat(transformed, \";\"));\n                  this.is_gap_defined = true;\n                }\n                break;\n              }\n            case 'content':\n              {\n                rule = '';\n                if (transformed !== undefined && !is_pseudo_selecotr(selector) && !is_parent_selector(selector)) {\n                  this.content[this.compose_selector(coords)] = transformed;\n                }\n              }\n            case 'seed':\n              {\n                rule = '';\n                break;\n              }\n            case 'place-cell':\n            case 'place':\n            case 'position':\n            case 'offset':\n              {\n                if (!is_host_selector(selector)) {\n                  rule = transformed;\n                }\n                break;\n              }\n            case 'use':\n              {\n                if (token.value.length) {\n                  this.compose(coords, token.value);\n                }\n                rule = '';\n                break;\n              }\n            default:\n              {\n                rule = transformed;\n              }\n          }\n        }\n        return rule;\n      }\n    }, {\n      key: \"get_raw_value\",\n      value: function get_raw_value(token) {\n        var raw = token.raw();\n        if (is_nil(raw)) {\n          raw = '';\n        }\n        var _raw$split = raw.split(token.property),\n          _raw$split2 = _toArray(_raw$split),\n          _ = _raw$split2[0],\n          rest = _raw$split2.slice(1); // It's not accurate, will be solved after the rewrite of css parser.\n        rest = rest.join(token.property).replace(/^\\s*:\\s*/, '').replace(/[;}<]$/, '').trim().replace(/[;}<]$/, '');\n        return rest;\n      }\n    }, {\n      key: \"pre_compose_rule\",\n      value: function pre_compose_rule(token, _coords) {\n        var _this5 = this;\n        var coords = Object.assign({}, _coords);\n        var prop = token.property;\n        switch (prop) {\n          case '@grid':\n            {\n              var value_group = token.value.reduce(function (ret, v) {\n                var composed = _this5.compose_value(v, coords);\n                if (composed && composed.value) ret.push(composed.value);\n                return ret;\n              }, []);\n              var value = value_group.join(', ');\n              var name = prop.substr(1);\n              var transformed = Property[name](value, {\n                max_grid: _coords.max_grid\n              });\n              this.grid = transformed.grid;\n              break;\n            }\n          case '@use':\n            {\n              if (token.value.length) {\n                this.pre_compose(coords, token.value);\n              }\n              break;\n            }\n        }\n      }\n    }, {\n      key: \"pre_compose\",\n      value: function pre_compose(coords, tokens) {\n        var _this6 = this;\n        if (is_nil(this.seed)) {\n          (tokens || this.tokens).forEach(function (token) {\n            if (token.type === 'rule' && token.property === '@seed') {\n              _this6.seed = _this6.get_raw_value(token);\n            }\n            if (token.type === 'pseudo' && is_host_selector(token.selector)) {\n              var _iterator8 = _createForOfIteratorHelper(make_array(token.styles)),\n                _step8;\n              try {\n                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                  var t = _step8.value;\n                  if (t.type === 'rule' && t.property === '@seed') {\n                    _this6.seed = _this6.get_raw_value(t);\n                  }\n                }\n              } catch (err) {\n                _iterator8.e(err);\n              } finally {\n                _iterator8.f();\n              }\n            }\n          });\n          if (is_nil(this.seed)) {\n            this.seed = coords.seed_value;\n          } else {\n            coords.update_random(this.seed);\n          }\n        }\n        (tokens || this.tokens).forEach(function (token) {\n          switch (token.type) {\n            case 'rule':\n              {\n                _this6.pre_compose_rule(token, coords);\n                break;\n              }\n            case 'pseudo':\n              {\n                if (is_host_selector(token.selector)) {\n                  (token.styles || []).forEach(function (token) {\n                    _this6.pre_compose_rule(token, coords);\n                  });\n                }\n                break;\n              }\n          }\n        });\n      }\n    }, {\n      key: \"compose\",\n      value: function compose(coords, tokens, initial) {\n        var _this7 = this;\n        this.coords.push(coords);\n        (tokens || this.tokens).forEach(function (token, i) {\n          if (token.skip) return false;\n          if (initial && _this7.grid) return false;\n          switch (token.type) {\n            case 'rule':\n              {\n                _this7.add_rule(_this7.compose_selector(coords), _this7.compose_rule(token, coords));\n                break;\n              }\n            case 'pseudo':\n              {\n                if (token.selector.startsWith(':doodle')) {\n                  token.selector = token.selector.replace(/^\\:+doodle/, ':host');\n                }\n                var special = is_special_selector(token.selector);\n                if (special) {\n                  token.skip = true;\n                }\n                token.selector.split(',').forEach(function (selector) {\n                  var pseudo = token.styles.map(function (s) {\n                    return _this7.compose_rule(s, coords, selector);\n                  });\n                  var composed = special ? selector : _this7.compose_selector(coords, selector);\n                  _this7.add_rule(composed, pseudo);\n                });\n                break;\n              }\n            case 'cond':\n              {\n                var fn = Selector[token.name.substr(1)];\n                if (fn) {\n                  var args = token.arguments.map(function (arg) {\n                    return _this7.compose_argument(arg, coords);\n                  });\n                  var result = _this7.apply_func(fn, coords, args);\n                  if (result) {\n                    _this7.compose(coords, token.styles);\n                  }\n                }\n                break;\n              }\n            case 'keyframes':\n              {\n                if (!_this7.keyframes[token.name]) {\n                  _this7.keyframes[token.name] = function (coords) {\n                    return \"\\n              \".concat(join(token.steps.map(function (step) {\n                      return \"\\n                \".concat(step.name, \" {\\n                  \").concat(join(step.styles.map(function (s) {\n                        return _this7.compose_rule(s, coords);\n                      })), \"\\n                }\\n              \");\n                    })), \"\\n            \");\n                  };\n                }\n              }\n          }\n        });\n      }\n    }, {\n      key: \"output\",\n      value: function output() {\n        var _this8 = this;\n        for (var _i10 = 0, _Object$entries5 = Object.entries(this.rules); _i10 < _Object$entries5.length; _i10++) {\n          var _Object$entries5$_i = _slicedToArray(_Object$entries5[_i10], 2),\n            selector = _Object$entries5$_i[0],\n            rule = _Object$entries5$_i[1];\n          if (is_parent_selector(selector)) {\n            this.styles.container += \"\\n          .container {\\n            \".concat(join(rule), \"\\n          }\\n        \");\n          } else {\n            var target = is_host_selector(selector) ? 'host' : 'cells';\n            var value = join(rule).trim();\n            var name = target === 'host' ? \"\".concat(selector, \", .host\") : selector;\n            this.styles[target] += \"\".concat(name, \" { \").concat(value, \" }\");\n          }\n        }\n        if (this.uniforms.time) {\n          this.styles.container += \"\\n        :host, .host {\\n          animation: \".concat(uniform_time.animation, \";\\n        }\\n      \");\n          this.styles.keyframes += \"\\n       @keyframes \".concat(uniform_time['animation-name'], \" {\\n         from { --\").concat(uniform_time.name, \": 0 }\\n         to { --\").concat(uniform_time.name, \": \").concat(uniform_time['animation-duration'] / 10, \" }\\n       }\\n      \");\n        }\n        this.coords.forEach(function (coords, i) {\n          for (var _i11 = 0, _Object$entries6 = Object.entries(_this8.keyframes); _i11 < _Object$entries6.length; _i11++) {\n            var _Object$entries6$_i = _slicedToArray(_Object$entries6[_i11], 2),\n              _name = _Object$entries6$_i[0],\n              keyframe = _Object$entries6$_i[1];\n            var aname = _this8.compose_aname(_name, coords.count);\n            _this8.styles.keyframes += \"\\n          \".concat(maybe(i === 0, \"@keyframes \".concat(_name, \" { \").concat(keyframe(coords), \" }\")), \"\\n          @keyframes \").concat(aname, \" {\\n            \").concat(keyframe(coords), \"\\n          }\\n        \");\n          }\n        });\n        return {\n          props: this.props,\n          styles: this.styles,\n          grid: this.grid,\n          seed: this.seed,\n          random: this.random,\n          doodles: this.doodles,\n          shaders: this.shaders,\n          canvas: this.canvas,\n          pattern: this.pattern,\n          uniforms: this.uniforms,\n          content: this.content\n        };\n      }\n    }]);\n    return Rules;\n  }();\n  function generate_css(tokens, grid_size, seed_value, max_grid, seed_random) {\n    var rules = new Rules(tokens);\n    var random = seed_random || seedrandom(String(seed_value));\n    var context = {};\n    function update_random(seed) {\n      random = seedrandom(String(seed));\n    }\n    function rand() {\n      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var end = arguments.length > 1 ? arguments[1] : undefined;\n      if (arguments.length == 1) {\n        var _ref71 = [0, start];\n        start = _ref71[0];\n        end = _ref71[1];\n      }\n      return lerp(random(), start, end);\n    }\n    function pick() {\n      for (var _len34 = arguments.length, items = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {\n        items[_key34] = arguments[_key34];\n      }\n      var args = items.reduce(function (acc, n) {\n        return acc.concat(n);\n      }, []);\n      return args[~~(random() * args.length)];\n    }\n    function shuffle(arr) {\n      var ret = _toConsumableArray(arr);\n      var m = arr.length;\n      while (m) {\n        var i = ~~(random() * m--);\n        var t = ret[m];\n        ret[m] = ret[i];\n        ret[i] = t;\n      }\n      return ret;\n    }\n    rules.pre_compose({\n      x: 1,\n      y: 1,\n      z: 1,\n      count: 1,\n      context: {},\n      grid: {\n        x: 1,\n        y: 1,\n        z: 1,\n        count: 1\n      },\n      random: random,\n      rand: rand,\n      pick: pick,\n      shuffle: shuffle,\n      max_grid: max_grid,\n      update_random: update_random,\n      seed_value: seed_value\n    });\n    var _rules$output = rules.output(),\n      grid = _rules$output.grid,\n      seed = _rules$output.seed;\n    if (grid) {\n      grid_size = grid;\n    }\n    if (seed) {\n      seed = String(seed);\n      random = seedrandom(seed);\n    } else {\n      seed = seed_value;\n    }\n    if (is_nil(seed)) {\n      seed = Date.now();\n      random = seedrandom(seed);\n    }\n    seed = String(seed);\n    rules.seed = seed;\n    rules.random = random;\n    rules.reset();\n    if (grid_size.z == 1) {\n      for (var y = 1, count = 0; y <= grid_size.y; ++y) {\n        for (var x = 1; x <= grid_size.x; ++x) {\n          rules.compose({\n            x: x,\n            y: y,\n            z: 1,\n            count: ++count,\n            grid: grid_size,\n            context: context,\n            rand: rand,\n            pick: pick,\n            shuffle: shuffle,\n            random: random,\n            seed: seed,\n            max_grid: max_grid\n          });\n        }\n      }\n    } else {\n      for (var z = 1, _count = 0; z <= grid_size.z; ++z) {\n        rules.compose({\n          x: 1,\n          y: 1,\n          z: z,\n          count: ++_count,\n          grid: grid_size,\n          context: context,\n          rand: rand,\n          pick: pick,\n          shuffle: shuffle,\n          random: random,\n          seed: seed,\n          max_grid: max_grid\n        });\n      }\n    }\n    return rules.output();\n  }\n  function create_shader(gl, type, source) {\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    return shader;\n  }\n  function create_program(gl, vss, fss) {\n    var vs = create_shader(gl, gl.VERTEX_SHADER, vss);\n    var fs = create_shader(gl, gl.FRAGMENT_SHADER, fss);\n    var prog = gl.createProgram();\n    gl.attachShader(prog, vs);\n    gl.attachShader(prog, fs);\n    gl.linkProgram(prog);\n    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {\n      console.warn('Link failed: ' + gl.getProgramInfoLog(prog));\n      console.warn('vs info-log: ' + gl.getShaderInfoLog(vs));\n      console.warn('fs info-log: ' + gl.getShaderInfoLog(fs));\n    }\n    return prog;\n  }\n  function add_uniform(fragment, uniform) {\n    if (!fragment.includes(uniform)) {\n      return uniform + '\\n' + fragment;\n    }\n    return fragment;\n  }\n  var fragment_head = \"#version 300 es\\n  precision highp float;\\n  out vec4 FragColor;\\n\";\n  var default_vertex_shader = \"#version 300 es\\n  in vec4 position;\\n  void main() {\\n    gl_Position = position;\\n  }\\n\";\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL\n  function load_texture(gl, image, i) {\n    var texture = gl.createTexture();\n    gl.activeTexture(gl['TEXTURE' + i]);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n\n    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  }\n  function draw_shader(shaders, width, height, seed) {\n    var result = Cache.get(shaders);\n    if (result) {\n      return Promise.resolve(result);\n    }\n    var canvas = document.createElement('canvas');\n    var ratio = window.devicePixelRatio || 1;\n    width *= ratio;\n    height *= ratio;\n    canvas.width = width;\n    canvas.height = height;\n    var gl = canvas.getContext('webgl2', {\n      preserveDrawingBuffer: true\n    });\n    if (!gl) return Promise.resolve('');\n\n    // resolution uniform\n    var fragment = add_uniform(shaders.fragment || '', 'uniform vec2 u_resolution;');\n    fragment = add_uniform(fragment, 'uniform float u_time;');\n    fragment = add_uniform(fragment, 'uniform float u_timeDelta;');\n    fragment = add_uniform(fragment, 'uniform int u_frameIndex;');\n    fragment = add_uniform(fragment, 'uniform vec2 u_seed;');\n    // fragment = add_uniform(fragment, 'uniform vec4 u_mouse;');\n\n    // texture uniform\n    shaders.textures.forEach(function (n) {\n      var uniform = \"uniform sampler2D \".concat(n.name, \";\");\n      fragment = add_uniform(fragment, uniform);\n    });\n    var isShaderToyFragment = /(^|[^\\w\\_])void\\s+mainImage\\(\\s*out\\s+vec4\\s+fragColor,\\s*in\\s+vec2\\s+fragCoord\\s*\\)/mg.test(fragment);\n    if (isShaderToyFragment) {\n      fragment = \"// https://www.shadertoy.com/howto\\n\\n#define iResolution vec3(u_resolution, 0)\\n#define iTime u_time\\n#define iTimeDelta u_timeDelta\\n#define iFrame u_frameIndex\\n\\n\".concat(shaders.textures.map(function (n, i) {\n        return \"#define iChannel\".concat(i, \" \").concat(n.name);\n      }).join('\\n'), \"\\n\\n\").concat(fragment, \"\\n\\nvoid main() {\\n  mainImage(FragColor, gl_FragCoord.xy);\\n}\");\n    }\n    var program = create_program(gl, shaders.vertex || default_vertex_shader, fragment_head + fragment);\n\n    // position in vertex shader\n    var positionAttributeLocation = gl.getAttribLocation(program, 'position');\n    var positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    var vertices = [-1, -1, -1, 1, 1, -1, 1, 1, -1, 1, 1, -1];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.useProgram(program);\n\n    // resolve uniforms\n    var uResolutionLoc = gl.getUniformLocation(program, \"u_resolution\");\n    gl.uniform2fv(uResolutionLoc, [width, height]);\n    shaders.textures.forEach(function (n, i) {\n      load_texture(gl, n.value, i);\n      gl.uniform1i(gl.getUniformLocation(program, n.name), i);\n    });\n\n    // vec2 u_seed, u_seed.x = hash(doodle.seed) / 1e16, u_seed.y = Math.random()\n    var uSeed = gl.getUniformLocation(program, \"u_seed\");\n    if (uSeed) {\n      gl.uniform2f(uSeed, hash(seed) / 1e16, Math.random());\n    }\n\n    // resolve image data in 72dpi :(\n    var uTimeLoc = gl.getUniformLocation(program, \"u_time\");\n    var uFrameLoc = gl.getUniformLocation(program, \"u_frameIndex\");\n    var uTimeDelta = gl.getUniformLocation(program, \"u_timeDelta\");\n    if (uTimeLoc || uTimeDelta || uFrameLoc) {\n      var frameIndex = 0;\n      var currentTime = 0;\n      return Promise.resolve(Cache.set(shaders, function (t) {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        if (uTimeLoc) gl.uniform1f(uTimeLoc, t / 1000);\n        if (uFrameLoc) gl.uniform1i(uFrameLoc, frameIndex++);\n        if (uTimeDelta) {\n          gl.uniform1f(uTimeDelta, (currentTime - t) / 1000);\n          currentTime = t;\n        }\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        return canvas.toDataURL();\n      }));\n    } else {\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\n      return Promise.resolve(Cache.set(shaders, canvas.toDataURL()));\n    }\n  }\n  function readStatement(iter, token) {\n    var fragment = [];\n    while (iter.next()) {\n      var _iter$get19 = iter.get(),\n        curr = _iter$get19.curr,\n        next = _iter$get19.next;\n      var isStatementBreak = !next || curr.isSymbol(';') || next.isSymbol('}');\n      fragment.push(curr);\n      if (isStatementBreak) {\n        break;\n      }\n    }\n    if (fragment.length) {\n      token.value = joinToken(fragment);\n    }\n    return token;\n  }\n  function walk(iter, parentToken) {\n    var rules = [];\n    var fragment = [];\n    var tokenType = parentToken && parentToken.type || '';\n    var stack = [];\n    var _loop2 = function _loop2() {\n      var _iter$get20 = iter.get(),\n        prev = _iter$get20.prev,\n        curr = _iter$get20.curr,\n        next = _iter$get20.next;\n      var isBlockBreak = !next || curr.isSymbol('}');\n      if (tokenType === 'block' && isBlockBreak) {\n        if (!next && rules.length && !curr.isSymbol('}')) {\n          rules[rules.length - 1].value += ';' + curr.value;\n        }\n        parentToken.value = rules;\n        return \"break\";\n      } else if (curr.isSymbol('{') && fragment.length && !stack.length) {\n        var selectors = parseSelector(fragment);\n        if (!selectors.length) {\n          return \"continue\";\n        }\n        var block = walk(iter, {\n          type: 'block',\n          name: 'unkown',\n          value: []\n        });\n        selectors.forEach(function (selector) {\n          var newBlock = Object.assign({}, block, {\n            name: selector.name,\n            args: selector.args\n          });\n          rules.push(newBlock);\n        });\n        fragment = [];\n      } else if (curr.isSymbol(':') && fragment.length && !stack.length) {\n        var prop = joinToken(fragment);\n        rules.push(readStatement(iter, {\n          type: 'statement',\n          name: prop,\n          value: ''\n        }));\n        if (tokenType == 'block') {\n          parentToken.value = rules;\n        }\n        fragment = [];\n      } else if (curr.isSymbol(';')) {\n        if (rules.length && fragment.length) {\n          rules[rules.length - 1].value += ';' + joinToken(fragment);\n          fragment = [];\n        }\n      } else {\n        if (curr.isSymbol('(')) {\n          stack.push(curr);\n        }\n        if (curr.isSymbol(')')) {\n          stack.pop();\n        }\n        fragment.push(curr);\n      }\n    };\n    while (iter.next()) {\n      var _ret2 = _loop2();\n      if (_ret2 === \"break\") break;\n      if (_ret2 === \"continue\") continue;\n    }\n    if (rules.length && tokenType == 'block') {\n      parentToken.value = rules;\n    }\n    return tokenType ? parentToken : rules;\n  }\n  function joinToken(tokens) {\n    return tokens.filter(function (token, i) {\n      if (token.isSymbol(';') && i === tokens.length - 1) return false;\n      return true;\n    }).map(function (n) {\n      return n.value;\n    }).join('');\n  }\n  function parseSelector(tokens) {\n    var iter = iterator$1(tokens);\n    var groups = [];\n    var selectorName = '';\n    var args = [];\n    var fragments = [];\n    var stack = [];\n    while (iter.next()) {\n      var _iter$get21 = iter.get(),\n        curr = _iter$get21.curr,\n        next = _iter$get21.next;\n      if (!selectorName.length && curr.isWord()) {\n        selectorName = curr.value;\n      } else if (curr.isSymbol('(')) {\n        if (stack.length) {\n          fragments.push(curr.value);\n        }\n        stack.push(curr);\n      } else if (curr.isSymbol(')')) {\n        stack.pop();\n        if (stack.length) {\n          fragments.push(curr.value);\n        } else if (fragments.length) {\n          args.push(fragments.join(''));\n          fragments = [];\n        }\n      } else if (curr.isSymbol(',')) {\n        if (stack.length) {\n          args.push(fragments.join(''));\n          fragments = [];\n        } else {\n          if (fragments.length) {\n            args.push(fragments.join(''));\n            fragments = [];\n          }\n          if (selectorName) {\n            groups.push({\n              name: selectorName,\n              args: args\n            });\n            selectorName = '';\n            args = [];\n            fragments = [];\n          }\n        }\n      } else {\n        fragments.push(curr.value);\n      }\n    }\n    if (selectorName) {\n      groups.push({\n        name: selectorName,\n        args: args\n      });\n    }\n    return groups.filter(function (v, i, self) {\n      var idx = self.findIndex(function (n) {\n        return n.name === v.name && v.args.join('') == n.args.join('');\n      });\n      return idx === i;\n    });\n  }\n  function parse(source) {\n    var iter = iterator$1(scan(source));\n    var tokens = walk(iter);\n    return tokens;\n  }\n  function generate_shader(input, grid) {\n    return \"\\n    vec3 mapping(vec2 uv, vec2 grid) {\\n      vec2 _grid = 1.0/grid;\\n      float x = ceil(uv.x/_grid.x);\\n      float y = ceil(grid.y - uv.y/_grid.y);\\n      float i = x + (y - 1.0) * y;\\n      return vec3(x, y, i);\\n    }\\n    vec4 getColor(float x, float y, float i, float I, float X, float Y, float t) {\\n      vec4 color = vec4(0, 0, 0, 0);\\n      \".concat(input, \"\\n      return color;\\n    }\\n    void main() {\\n      vec2 uv = gl_FragCoord.xy/u_resolution.xy;\\n      vec2 grid = vec2(\").concat(grid.x, \", \").concat(grid.y, \");\\n      vec3 p = mapping(uv, grid);\\n      FragColor = getColor(p.x, p.y, p.z, grid.x * grid.y, grid.x, grid.y, u_time);\\n    }\\n  \");\n  }\n  function generate_statement(token, extra) {\n    if (token.name === 'fill') {\n      var _extra$get_rgba_color = extra.get_rgba_color(token.value),\n        r = _extra$get_rgba_color.r,\n        g = _extra$get_rgba_color.g,\n        b = _extra$get_rgba_color.b,\n        a = _extra$get_rgba_color.a;\n      return {\n        type: 'statement',\n        value: \"\\ncolor = vec4(\".concat(float(r / 255), \", \").concat(float(g / 255), \", \").concat(float(b / 255), \", \").concat(float(a), \");\\n\")\n      };\n    }\n    if (token.name == 'grid') {\n      return {\n        type: 'grid',\n        value: token.value\n      };\n    }\n    return {\n      type: 'statement',\n      value: ''\n    };\n  }\n  function generate_block(token, extra) {\n    if (token.name === 'match') {\n      var cond = token.args[0];\n      var values = [];\n      token.value.forEach(function (t) {\n        var statement = generate_statement(t, extra);\n        if (statement.type == 'statement') {\n          values.push(statement.value);\n        }\n      });\n      return \"\\n      if (\".concat(cond, \") {\\n        \").concat(values.join(''), \"\\n      }\\n    \");\n    }\n    return '';\n  }\n  function float(n) {\n    return String(n).includes('.') ? n : n + '.0';\n  }\n  function draw_pattern(code, extra) {\n    var tokens = parse(code);\n    var result = [];\n    var grid = {\n      x: 1,\n      y: 1\n    };\n    tokens.forEach(function (token) {\n      if (token.type === 'statement') {\n        var statement = generate_statement(token, extra);\n        if (statement.type == 'statement') {\n          result.push(statement.value);\n        }\n        if (statement.type === 'grid') {\n          grid = get_grid(statement.value);\n        }\n      } else if (token.type === 'block') {\n        result.push(generate_block(token, extra));\n      }\n    });\n    return generate_shader(result.join(''), grid);\n  }\n  var nextId = next_id();\n  function draw_canvas(code) {\n    var result = Cache.get(code);\n    if (result) {\n      return Promise.resolve(result);\n    }\n    var name = nextId('css-doodle-paint');\n    var wrapped = generate(name, code);\n    var blob = new Blob([wrapped], {\n      type: 'text/javascript'\n    });\n    try {\n      if (CSS.paintWorklet) {\n        CSS.paintWorklet.addModule(URL.createObjectURL(blob));\n      }\n    } catch (e) {}\n    return Promise.resolve(Cache.set(code, \"paint(\".concat(name, \")\")));\n  }\n  function generate(name, code) {\n    code = un_entity(code);\n    // make it so\n    if (!code.includes('paint(')) {\n      code = \"\\n      paint(ctx, {width, height}, props) {\\n        \".concat(code, \"\\n      }\\n    \");\n    }\n    return \"\\n    registerPaint('\".concat(name, \"', class {\\n      \").concat(code, \"\\n    })\\n  \");\n  }\n  function svg_to_png(svg, width, height, scale) {\n    return new Promise(function (resolve, reject) {\n      var source = \"data:image/svg+xml;utf8,\".concat(encodeURIComponent(svg));\n      function action() {\n        var img = new Image();\n        img.crossOrigin = 'anonymous';\n        img.src = source;\n        img.onload = function () {\n          var canvas = document.createElement('canvas');\n          var ctx = canvas.getContext('2d');\n          var dpr = window.devicePixelRatio || 1;\n          /* scale with devicePixelRatio only when the scale equals 1 */\n          if (scale != 1) {\n            dpr = 1;\n          }\n          canvas.width = width * dpr;\n          canvas.height = height * dpr;\n          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n          try {\n            canvas.toBlob(function (blob) {\n              resolve({\n                blob: blob,\n                source: source,\n                url: URL.createObjectURL(blob)\n              });\n            });\n          } catch (e) {\n            reject(e);\n          }\n        };\n      }\n      if (is_safari()) {\n        cache_image(source, action, 200);\n      } else {\n        action();\n      }\n    });\n  }\n  function get_all_variables(element) {\n    if (typeof getComputedStyle === 'undefined') {\n      return '';\n    }\n    var ret = {};\n    if (element.computedStyleMap) {\n      var _iterator9 = _createForOfIteratorHelper(element.computedStyleMap()),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _step9$value = _slicedToArray(_step9.value, 2),\n            prop = _step9$value[0],\n            value = _step9$value[1];\n          if (prop.startsWith('--')) {\n            ret[prop] = value[0][0];\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    } else {\n      var styles = getComputedStyle(element);\n      var _iterator10 = _createForOfIteratorHelper(styles),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _prop = _step10.value;\n          if (_prop.startsWith('--')) {\n            ret[_prop] = styles.getPropertyValue(_prop);\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n    return inline(ret);\n  }\n  function _get_variable(element, name) {\n    if (typeof getComputedStyle === 'undefined') {\n      return '';\n    }\n    return getComputedStyle(element).getPropertyValue(name).trim().replace(/^\\(|\\)$/g, '');\n  }\n  function inline(map) {\n    var result = [];\n    for (var _i12 = 0, _Object$entries7 = Object.entries(map); _i12 < _Object$entries7.length; _i12++) {\n      var _Object$entries7$_i = _slicedToArray(_Object$entries7[_i12], 2),\n        prop = _Object$entries7$_i[0],\n        value = _Object$entries7$_i[1];\n      result.push(prop + ':' + value);\n    }\n    return result.join(';');\n  }\n  function transform(color) {\n    var _color$replace$split = color.replace(/rgba?\\((.+)\\)/, function (_, v) {\n        return v;\n      }).split(/,\\s*/),\n      _color$replace$split2 = _slicedToArray(_color$replace$split, 4),\n      r = _color$replace$split2[0],\n      g = _color$replace$split2[1],\n      b = _color$replace$split2[2],\n      _color$replace$split3 = _color$replace$split2[3],\n      a = _color$replace$split3 === void 0 ? 1 : _color$replace$split3;\n    return {\n      r: r,\n      g: g,\n      b: b,\n      a: a\n    };\n  }\n  function _get_rgba_color(root, value) {\n    var element = root.querySelector('#defs');\n    if (!element) {\n      return {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 1\n      };\n    }\n    element.style.color = value;\n    return transform(getComputedStyle(element).color);\n  }\n  var STEP60 = 1000 / 60; // 60fps\n  var STEP1 = 1000 / 1; // 1fps\n\n  function createAnimationFrame(fn) {\n    var id;\n    var time = 0;\n    var lastTime = 0;\n    var lastStep = 0;\n    var paused = false;\n    function loop(stamp) {\n      if (!time) time = stamp;\n      fn(time);\n      var step = stamp - lastTime;\n      if (step < STEP60) step = STEP60;\n      if (step > STEP1) step = lastStep || STEP1;\n      if (lastTime) time += step;\n      lastStep = step;\n      lastTime = stamp;\n      id = requestAnimationFrame(loop);\n    }\n    id = requestAnimationFrame(loop);\n    return {\n      resume: function resume() {\n        if (id && paused) {\n          paused = false;\n          id = requestAnimationFrame(loop);\n        }\n      },\n      pause: function pause() {\n        if (id) {\n          cancelAnimationFrame(id);\n          paused = true;\n        }\n      },\n      cancel: function cancel() {\n        if (id) {\n          paused = false;\n          cancelAnimationFrame(id);\n          id = null;\n        }\n      }\n    };\n  }\n  if (typeof customElements !== 'undefined') {\n    var Doodle = /*#__PURE__*/function (_HTMLElement) {\n      _inherits(Doodle, _HTMLElement);\n      function Doodle() {\n        var _this9;\n        _classCallCheck(this, Doodle);\n        _this9 = _possibleConstructorReturn(this, _getPrototypeOf(Doodle).call(this));\n        _this9.doodle = _this9.attachShadow({\n          mode: 'open'\n        });\n        _this9.animations = [];\n        _this9.extra = {\n          get_variable: function get_variable(name) {\n            return _get_variable(_assertThisInitialized(_assertThisInitialized(_this9)), name);\n          },\n          get_rgba_color: function get_rgba_color(value) {\n            return _get_rgba_color(_this9.shadowRoot, value);\n          }\n        };\n        return _this9;\n      }\n      _createClass(Doodle, [{\n        key: \"connectedCallback\",\n        value: function connectedCallback(again) {\n          var _this10 = this;\n          if (this.innerHTML) {\n            this.load(again);\n          } else {\n            setTimeout(function () {\n              return _this10.load(again);\n            });\n          }\n        }\n      }, {\n        key: \"disconnectedCallback\",\n        value: function disconnectedCallback() {\n          this.cleanup();\n        }\n      }, {\n        key: \"cleanup\",\n        value: function cleanup() {\n          Cache.clear();\n          var _iterator11 = _createForOfIteratorHelper(this.animations),\n            _step11;\n          try {\n            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n              var animation = _step11.value;\n              animation.cancel();\n            }\n          } catch (err) {\n            _iterator11.e(err);\n          } finally {\n            _iterator11.f();\n          }\n          this.animations = [];\n        }\n      }, {\n        key: \"update\",\n        value: function update(styles) {\n          var _this11 = this;\n          this.cleanup();\n          // Use old rules to update\n          if (!styles) {\n            styles = un_entity(this.innerHTML);\n          }\n          if (this.innerHTML !== styles) {\n            this.innerHTML = styles;\n          }\n          if (!this.grid_size) {\n            this.grid_size = this.get_grid();\n          }\n          var _this$grid_size = this.grid_size,\n            gx = _this$grid_size.x,\n            gy = _this$grid_size.y,\n            gz = _this$grid_size.z;\n          var use = this.get_use();\n          var old_content = '';\n          if (this.compiled) {\n            old_content = this.compiled.content;\n          }\n          var compiled = this.generate(parse$6(use + styles, this.extra));\n          var grid = compiled.grid || this.get_grid();\n          var x = grid.x,\n            y = grid.y,\n            z = grid.z;\n          var should_rebuild = !this.shadowRoot.innerHTML || gx !== x || gy !== y || gz !== z || JSON.stringify(old_content) !== JSON.stringify(compiled.content);\n          Object.assign(this.grid_size, grid);\n          if (should_rebuild) {\n            return compiled.grid ? this.build_grid(compiled, grid) : this.build_grid(this.generate(parse$6(use + styles, this.extra)), grid);\n          }\n          var replace = this.replace(compiled);\n          this.set_content('.style-keyframes', replace(compiled.styles.keyframes));\n          if (compiled.props.has_animation) {\n            this.set_content('.style-cells', '');\n            this.set_content('.style-container', '');\n          }\n          setTimeout(function () {\n            _this11.set_content('.style-container', replace(get_grid_styles(_this11.grid_size) + compiled.styles.host + compiled.styles.container));\n            _this11.set_content('.style-cells', replace(compiled.styles.cells));\n          });\n        }\n      }, {\n        key: \"get_max_grid\",\n        value: function get_max_grid() {\n          return this.hasAttribute('experimental') ? 256 : 64;\n        }\n      }, {\n        key: \"get_grid\",\n        value: function get_grid() {\n          return parse_grid(this.attr('grid'), this.get_max_grid());\n        }\n      }, {\n        key: \"get_use\",\n        value: function get_use() {\n          var use = String(this.attr('use') || '').trim();\n          if (/^var\\(/.test(use)) {\n            use = \"@use:\".concat(use, \";\");\n          }\n          return use;\n        }\n      }, {\n        key: \"attr\",\n        value: function attr(name, value) {\n          if (arguments.length === 1) {\n            return this.getAttribute(name);\n          }\n          if (arguments.length === 2) {\n            this.setAttribute(name, value);\n            return value;\n          }\n        }\n      }, {\n        key: \"generate\",\n        value: function generate(parsed) {\n          var grid = this.get_grid();\n          var seed = this.attr('seed') || this.attr('data-seed');\n          if (is_nil(seed)) {\n            seed = Date.now();\n          }\n          var compiled = this.compiled = generate_css(parsed, grid, seed, this.get_max_grid());\n          this._seed_value = compiled.seed;\n          this._seed_random = compiled.random;\n          return compiled;\n        }\n      }, {\n        key: \"doodle_to_image\",\n        value: function doodle_to_image(code, options, fn) {\n          if (typeof options === 'function') {\n            fn = options;\n            options = null;\n          }\n          code = ':doodle { width:100%;height:100% }' + code;\n          var parsed = parse$6(code, this.extra);\n          var _grid = parse_grid('');\n          var compiled = generate_css(parsed, _grid, this._seed_value, this.get_max_grid(), this._seed_random);\n          var grid = compiled.grid ? compiled.grid : _grid;\n          var _compiled$styles = compiled.styles,\n            keyframes = _compiled$styles.keyframes,\n            host = _compiled$styles.host,\n            container = _compiled$styles.container,\n            cells = _compiled$styles.cells;\n          var viewBox = '';\n          if (options && options.arg) {\n            var v = get_grid(options.arg);\n            if (v.x && v.y) {\n              viewBox = \"viewBox=\\\"0 0 \".concat(v.x, \" \").concat(v.y, \"\\\"\");\n            }\n          }\n          var replace = this.replace(compiled);\n          var grid_container = create_grid(grid, compiled.content);\n          var size = options && options.width && options.height ? \"width=\\\"\".concat(options.width, \"\\\" height=\\\"\").concat(options.height, \"\\\"\") : '';\n          replace(\"\\n        <svg \".concat(size, \" xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"none\\\" \").concat(viewBox, \">\\n          <foreignObject width=\\\"100%\\\" height=\\\"100%\\\">\\n            <div class=\\\"host\\\" width=\\\"100%\\\" height=\\\"100%\\\" xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\\n              <style>\\n                \").concat(get_basic_styles(), \"\\n                \").concat(get_grid_styles(grid), \"\\n                \").concat(host, \"\\n                \").concat(container, \"\\n                \").concat(cells, \"\\n                \").concat(keyframes, \"\\n              </style>\\n              <svg id=\\\"defs\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" style=\\\"width:0; height:0\\\"></svg>\\n              \").concat(grid_container, \"\\n            </div>\\n          </foreignObject>\\n        </svg>\\n      \")).then(function (result) {\n            var source = \"data:image/svg+xml;base64,\".concat(window.btoa(unescape(encodeURIComponent(result))));\n            if (is_safari()) {\n              cache_image(source);\n            }\n            fn(source);\n          });\n        }\n      }, {\n        key: \"pattern_to_image\",\n        value: function pattern_to_image(_ref72, fn) {\n          var code = _ref72.code,\n            cell = _ref72.cell,\n            id = _ref72.id;\n          var shader = draw_pattern(code, this.extra);\n          this.shader_to_image({\n            shader: shader,\n            cell: cell,\n            id: id\n          }, fn);\n        }\n      }, {\n        key: \"canvas_to_image\",\n        value: function canvas_to_image(_ref73, fn) {\n          var code = _ref73.code;\n          draw_canvas(code).then(fn);\n        }\n      }, {\n        key: \"pause\",\n        value: function pause() {\n          this.setAttribute('cssd-paused-animation', true);\n          var _iterator12 = _createForOfIteratorHelper(this.animations),\n            _step12;\n          try {\n            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n              var animation = _step12.value;\n              animation.pause();\n            }\n          } catch (err) {\n            _iterator12.e(err);\n          } finally {\n            _iterator12.f();\n          }\n        }\n      }, {\n        key: \"resume\",\n        value: function resume() {\n          this.removeAttribute('cssd-paused-animation');\n          var _iterator13 = _createForOfIteratorHelper(this.animations),\n            _step13;\n          try {\n            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n              var animation = _step13.value;\n              animation.resume();\n            }\n          } catch (err) {\n            _iterator13.e(err);\n          } finally {\n            _iterator13.f();\n          }\n        }\n      }, {\n        key: \"shader_to_image\",\n        value: function shader_to_image(_ref74, fn) {\n          var _this12 = this;\n          var shader = _ref74.shader,\n            cell = _ref74.cell,\n            id = _ref74.id;\n          var parsed = typeof shader === 'string' ? parse$5(shader) : shader;\n          var element = this.doodle.getElementById(cell);\n          var seed = this.seed;\n          var set_shader_prop = function set_shader_prop(v) {\n            element.style.setProperty(id, \"url(\".concat(v, \")\"));\n          };\n          var tick = function tick(value) {\n            if (typeof value === 'function') {\n              var animation = createAnimationFrame(function (t) {\n                set_shader_prop(value(t));\n              });\n              _this12.animations.push(animation);\n              return '';\n            }\n            set_shader_prop(value);\n          };\n          var _ref75 = element && element.getBoundingClientRect() || {\n              width: 0,\n              height: 0\n            },\n            width = _ref75.width,\n            height = _ref75.height;\n          var ratio = window.devicePixelRatio || 1;\n          if (!parsed.textures.length || parsed.ticker) {\n            draw_shader(parsed, width, height, seed).then(tick).then(fn);\n          }\n          // Need to bind textures first\n          else {\n            var transforms = parsed.textures.map(function (texture) {\n              return new Promise(function (resolve) {\n                _this12.doodle_to_image(texture.value, {\n                  width: width,\n                  height: height\n                }, function (src) {\n                  var img = new Image();\n                  img.width = width * ratio;\n                  img.height = height * ratio;\n                  img.onload = function () {\n                    return resolve({\n                      name: texture.name,\n                      value: img\n                    });\n                  };\n                  img.src = src;\n                });\n              });\n            });\n            Promise.all(transforms).then(function (textures) {\n              parsed.textures = textures;\n              draw_shader(parsed, width, height, seed).then(tick).then(fn);\n            });\n          }\n        }\n      }, {\n        key: \"load\",\n        value: function load(again) {\n          var _this13 = this;\n          this.cleanup();\n          var use = this.get_use();\n          var parsed = parse$6(use + un_entity(this.innerHTML), this.extra);\n          var compiled = this.generate(parsed);\n          if (!again) {\n            if (this.hasAttribute('click-to-update')) {\n              this.addEventListener('click', function (e) {\n                return _this13.update();\n              });\n            }\n          }\n          this.grid_size = compiled.grid ? compiled.grid : this.get_grid();\n          this.build_grid(compiled, this.grid_size);\n        }\n      }, {\n        key: \"replace\",\n        value: function replace(_ref76) {\n          var _this14 = this;\n          var doodles = _ref76.doodles,\n            shaders = _ref76.shaders,\n            canvas = _ref76.canvas,\n            pattern = _ref76.pattern;\n          var doodle_ids = Object.keys(doodles);\n          var shader_ids = Object.keys(shaders);\n          var canvas_ids = Object.keys(canvas);\n          var pattern_ids = Object.keys(pattern);\n          var length = doodle_ids.length + canvas_ids.length + shader_ids.length + pattern_ids.length;\n          return function (input) {\n            if (!length) {\n              return Promise.resolve(input);\n            }\n            var mappings = [].concat(doodle_ids.map(function (id) {\n              if (input.includes(id)) {\n                return new Promise(function (resolve) {\n                  var _doodles$id = doodles[id],\n                    arg = _doodles$id.arg,\n                    doodle = _doodles$id.doodle;\n                  _this14.doodle_to_image(doodle, {\n                    arg: arg\n                  }, function (value) {\n                    return resolve({\n                      id: id,\n                      value: value\n                    });\n                  });\n                });\n              } else {\n                return Promise.resolve('');\n              }\n            }), shader_ids.map(function (id) {\n              if (input.includes(id)) {\n                return new Promise(function (resolve) {\n                  _this14.shader_to_image(shaders[id], function (value) {\n                    return resolve({\n                      id: id,\n                      value: value\n                    });\n                  });\n                });\n              } else {\n                return Promise.resolve('');\n              }\n            }), canvas_ids.map(function (id) {\n              if (input.includes(id)) {\n                return new Promise(function (resolve) {\n                  _this14.canvas_to_image(canvas[id], function (value) {\n                    return resolve({\n                      id: id,\n                      value: value\n                    });\n                  });\n                });\n              } else {\n                return Promise.resolve('');\n              }\n            }), pattern_ids.map(function (id) {\n              if (input.includes(id)) {\n                return new Promise(function (resolve) {\n                  _this14.pattern_to_image(pattern[id], function (value) {\n                    return resolve({\n                      id: id,\n                      value: value\n                    });\n                  });\n                });\n              } else {\n                return Promise.resolve('');\n              }\n            }));\n            return Promise.all(mappings).then(function (mapping) {\n              var _iterator14 = _createForOfIteratorHelper(mapping),\n                _step14;\n              try {\n                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                  var _step14$value = _step14.value,\n                    id = _step14$value.id,\n                    value = _step14$value.value;\n                  /* default to data-uri for doodle and pattern */\n                  var target = \"url(\".concat(value, \")\");\n                  /* canvas uses css painting api */\n                  if (/^canvas/.test(id)) target = value;\n                  /* shader uses css vars */\n                  if (/^shader|^pattern/.test(id)) target = \"var(--\".concat(id, \")\");\n                  input = input.replaceAll('${' + id + '}', target);\n                }\n              } catch (err) {\n                _iterator14.e(err);\n              } finally {\n                _iterator14.f();\n              }\n              return input;\n            });\n          };\n        }\n      }, {\n        key: \"build_grid\",\n        value: function build_grid(compiled, grid) {\n          var _this15 = this;\n          var _compiled$props = compiled.props,\n            has_transition = _compiled$props.has_transition,\n            has_animation = _compiled$props.has_animation;\n          var has_delay = has_transition || has_animation;\n          var _compiled$styles2 = compiled.styles,\n            keyframes = _compiled$styles2.keyframes,\n            host = _compiled$styles2.host,\n            container = _compiled$styles2.container,\n            cells = _compiled$styles2.cells;\n          var style_container = get_grid_styles(grid) + host + container;\n          var style_cells = has_delay ? '' : cells;\n          var uniforms = compiled.uniforms,\n            content = compiled.content;\n          var replace = this.replace(compiled);\n          this.doodle.innerHTML = \"\\n        <style>\".concat(get_basic_styles(), \"</style>\\n        <style class=\\\"style-keyframes\\\">\").concat(keyframes, \"</style>\\n        <style class=\\\"style-container\\\">\").concat(style_container, \"</style>\\n        <style class=\\\"style-cells\\\">\").concat(style_cells, \"</style>\\n        <svg id=\\\"defs\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" style=\\\"width:0;height:0\\\"></svg>\\n        \").concat(create_grid(grid, content), \"\\n      \");\n          this.set_content('.style-container', replace(style_container));\n          if (has_delay) {\n            setTimeout(function () {\n              _this15.set_content('.style-cells', replace(cells));\n            }, 50);\n          } else {\n            this.set_content('.style-cells', replace(cells));\n          }\n          if (uniforms.time) {\n            this.register_uniform_time();\n          }\n          if (uniforms.mousex || uniforms.mousey) {\n            this.register_uniform_mouse(uniforms);\n          } else {\n            this.remove_uniform_mouse();\n          }\n          if (uniforms.width || uniforms.height) {\n            this.register_uniform_resolution(uniforms);\n          } else {\n            this.remove_uniform_resolution();\n          }\n        }\n      }, {\n        key: \"register_uniform_mouse\",\n        value: function register_uniform_mouse(uniforms) {\n          var _this16 = this;\n          if (!this.uniform_mouse_callback) {\n            var _uniform_mousex = Uniforms.uniform_mousex,\n              _uniform_mousey = Uniforms.uniform_mousey;\n            this.uniform_mouse_callback = function (e) {\n              var data = e.detail || e;\n              if (uniforms.mousex) {\n                _this16.style.setProperty('--' + _uniform_mousex.name, data.offsetX);\n              }\n              if (uniforms.mousey) {\n                _this16.style.setProperty('--' + _uniform_mousey.name, data.offsetY);\n              }\n            };\n            this.addEventListener('pointermove', this.uniform_mouse_callback);\n            var event = new CustomEvent('pointermove', {\n              detail: {\n                offsetX: 0,\n                offsetY: 0\n              }\n            });\n            this.dispatchEvent(event);\n          }\n        }\n      }, {\n        key: \"remove_uniform_mouse\",\n        value: function remove_uniform_mouse() {\n          if (this.uniform_mouse_callback) {\n            var _uniform_mousex2 = Uniforms.uniform_mousex,\n              _uniform_mousey2 = Uniforms.uniform_mousey;\n            this.style.removeProperty('--' + _uniform_mousex2.name);\n            this.style.removeProperty('--' + _uniform_mousey2.name);\n            this.removeEventListener('pointermove', this.uniform_mouse_callback);\n            this.uniform_mouse_callback = null;\n          }\n        }\n      }, {\n        key: \"register_uniform_resolution\",\n        value: function register_uniform_resolution(uniforms) {\n          var _this17 = this;\n          if (!this.uniform_resolution_observer) {\n            var _uniform_width = Uniforms.uniform_width,\n              _uniform_height = Uniforms.uniform_height;\n            var setProperty = function setProperty() {\n              var box = _this17.getBoundingClientRect();\n              if (uniforms.width) {\n                _this17.style.setProperty('--' + _uniform_width.name, box.width);\n              }\n              if (uniforms.height) {\n                _this17.style.setProperty('--' + _uniform_height.name, box.height);\n              }\n            };\n            setProperty();\n            this.uniform_resolution_observer = new ResizeObserver(function (entries) {\n              var _iterator15 = _createForOfIteratorHelper(entries),\n                _step15;\n              try {\n                for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                  var entry = _step15.value;\n                  var data = entry.contentBoxSize || entry.contentRect;\n                  if (data) setProperty();\n                }\n              } catch (err) {\n                _iterator15.e(err);\n              } finally {\n                _iterator15.f();\n              }\n            });\n            this.uniform_resolution_observer.observe(this);\n          }\n        }\n      }, {\n        key: \"remove_uniform_resolution\",\n        value: function remove_uniform_resolution() {\n          if (this.uniform_resolution_observer) {\n            var _uniform_width2 = Uniforms.uniform_width,\n              _uniform_height2 = Uniforms.uniform_height;\n            this.style.removeProperty('--' + _uniform_width2.name);\n            this.style.removeProperty('--' + _uniform_height2.name);\n            this.uniform_resolution_observer.unobserve(this);\n            this.uniform_resolution_observer = null;\n          }\n        }\n      }, {\n        key: \"register_uniform_time\",\n        value: function register_uniform_time() {\n          if (!window.CSS || !window.CSS.registerProperty) {\n            return false;\n          }\n          if (!this.is_uniform_time_registered) {\n            var _uniform_time = Uniforms.uniform_time;\n            try {\n              CSS.registerProperty({\n                name: '--' + _uniform_time.name,\n                syntax: '<number>',\n                initialValue: 0,\n                inherits: true\n              });\n            } catch (e) {}\n            this.is_uniform_time_registered = true;\n          }\n        }\n      }, {\n        key: \"export\",\n        value: function _export() {\n          var _this18 = this;\n          var _ref77 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            scale = _ref77.scale,\n            name = _ref77.name,\n            download = _ref77.download,\n            detail = _ref77.detail;\n          return new Promise(function (resolve, reject) {\n            var variables = get_all_variables(_this18);\n            var html = _this18.doodle.innerHTML;\n            var _this18$getBoundingCl = _this18.getBoundingClientRect(),\n              width = _this18$getBoundingCl.width,\n              height = _this18$getBoundingCl.height;\n            scale = parseInt(scale) || 1;\n            var w = width * scale;\n            var h = height * scale;\n            var svg = \"\\n          <svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\\n            preserveAspectRatio=\\\"none\\\"\\n            viewBox=\\\"0 0 \".concat(width, \" \").concat(height, \"\\\"\\n            \").concat(is_safari() ? '' : \"width=\\\"\".concat(w, \"px\\\" height=\\\"\").concat(h, \"px\\\"\"), \"\\n          >\\n            <foreignObject width=\\\"100%\\\" height=\\\"100%\\\">\\n              <div\\n                class=\\\"host\\\"\\n                xmlns=\\\"http://www.w3.org/1999/xhtml\\\"\\n                style=\\\"width: \").concat(width, \"px; height: \").concat(height, \"px; \\\"\\n              >\\n                <style>.host { \").concat(entity(variables), \" }</style>\\n                \").concat(html, \"\\n              </div>\\n            </foreignObject>\\n          </svg>\\n        \");\n            if (download || detail) {\n              svg_to_png(svg, w, h, scale).then(function (_ref78) {\n                var source = _ref78.source,\n                  url = _ref78.url,\n                  blob = _ref78.blob;\n                resolve({\n                  width: w,\n                  height: h,\n                  svg: svg,\n                  blob: blob,\n                  source: source\n                });\n                if (download) {\n                  var a = document.createElement('a');\n                  a.download = normalize_png_name(name);\n                  a.href = url;\n                  a.click();\n                }\n              }).catch(function (error) {\n                reject(error);\n              });\n            } else {\n              resolve({\n                width: w,\n                height: h,\n                svg: svg\n              });\n            }\n          });\n        }\n      }, {\n        key: \"set_content\",\n        value: function set_content(selector, styles) {\n          var _this19 = this;\n          if (styles instanceof Promise) {\n            styles.then(function (value) {\n              _this19.set_content(selector, value);\n            });\n          } else {\n            var el = this.shadowRoot.querySelector(selector);\n            el && (el.styleSheet ? el.styleSheet.cssText = styles : el.innerHTML = styles);\n          }\n        }\n      }, {\n        key: \"grid\",\n        get: function get() {\n          return Object.assign({}, this.grid_size);\n        },\n        set: function set(grid) {\n          this.attr('grid', grid);\n          this.connectedCallback(true);\n        }\n      }, {\n        key: \"seed\",\n        get: function get() {\n          return this._seed_value;\n        },\n        set: function set(seed) {\n          this.attr('seed', seed);\n          this.connectedCallback(true);\n        }\n      }, {\n        key: \"use\",\n        get: function get() {\n          return this.attr('use');\n        },\n        set: function set(use) {\n          this.attr('use', use);\n          this.connectedCallback(true);\n        }\n      }]);\n      return Doodle;\n    }(_wrapNativeSuper(HTMLElement));\n    if (!customElements.get('css-doodle')) {\n      customElements.define('css-doodle', Doodle);\n    }\n  }\n  function get_basic_styles() {\n    var uniform_time = Uniforms.uniform_time;\n    var inherited_grid_props = get_props(/grid/).map(function (n) {\n      return \"\".concat(n, \": inherit;\");\n    }).join('');\n    return \"\\n    *, *::after, *::before {\\n      box-sizing: border-box;\\n    }\\n    :host, .host {\\n      display: block;\\n      visibility: visible;\\n      width: auto;\\n      height: auto;\\n      contain: content;\\n      --\".concat(uniform_time.name, \": 0\\n    }\\n    :host([hidden]), .host[hidden] {\\n      display: none\\n    }\\n    .container {\\n      position: relative;\\n      width: 100%;\\n      height: 100%;\\n      display: grid;\\n      \").concat(inherited_grid_props, \"\\n    }\\n    cell {\\n      position: relative;\\n      display: grid;\\n      place-items: center\\n    }\\n    svg {\\n      position: absolute;\\n      width: 100%;\\n      height: 100%\\n    }\\n    :host([cssd-paused-animation]),\\n    :host([cssd-paused-animation]) * {\\n      animation-play-state: paused !important\\n    }\\n  \");\n  }\n  function get_grid_styles(grid_obj) {\n    var _ref79 = grid_obj || {},\n      x = _ref79.x,\n      y = _ref79.y;\n    return \"\\n    :host, .host {\\n      grid-template-rows: repeat(\".concat(y, \", 1fr);\\n      grid-template-columns: repeat(\").concat(x, \", 1fr);\\n    }\\n  \");\n  }\n  function get_content(input) {\n    return is_nil(input) ? '' : input;\n  }\n  function create_cell(x, y, z, content) {\n    var child = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n    var id = cell_id(x, y, z);\n    var head = get_content(content['#' + id]);\n    var tail = get_content(child);\n    return \"<cell id=\\\"\".concat(id, \"\\\">\").concat(head).concat(tail, \"</cell>\");\n  }\n  function create_grid(grid_obj, content) {\n    var _ref80 = grid_obj || {},\n      x = _ref80.x,\n      y = _ref80.y,\n      z = _ref80.z;\n    var result = '';\n    if (z == 1) {\n      for (var j = 1; j <= y; ++j) {\n        for (var i = 1; i <= x; ++i) {\n          result += create_cell(i, j, 1, content);\n        }\n      }\n    } else {\n      var child = '';\n      for (var _i13 = z; _i13 >= 1; _i13--) {\n        var cell = create_cell(1, 1, _i13, content, child);\n        child = cell;\n      }\n      result = child;\n    }\n    return \"<grid class=\\\"container\\\">\".concat(result, \"</grid>\");\n  }\n  var index = make_tag_function(function (rules) {\n    if (typeof document !== 'undefined') {\n      var doodle = document.createElement('css-doodle');\n      if (doodle.update) {\n        doodle.update(rules);\n      }\n      return doodle;\n    }\n  });\n  return index;\n});","map":null,"metadata":{},"sourceType":"script"}